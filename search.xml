<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>51单片机基础</title>
    <url>/2020/04/07/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="微机原理——51单片机"><a href="#微机原理——51单片机" class="headerlink" title="微机原理——51单片机"></a>微机原理——51单片机</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单片机是单片微型计算机的简称，是典型的嵌入式微控制器。由运算器、控制器、存储器、输入输出设备构成。</p>
<a id="more"></a>
<p>单片机具有以下特点</p>
<ol>
<li>体积小、使用灵活、成本低、易于产业化</li>
<li>可靠性好，适应温度范围宽</li>
<li>易扩展</li>
<li>系统内无监控或系统管理程序<h3 id="1-1-数制"><a href="#1-1-数制" class="headerlink" title="1.1 数制"></a>1.1 数制</h3><h4 id="1-1-1-二进制、十六进制"><a href="#1-1-1-二进制、十六进制" class="headerlink" title="1.1.1 二进制、十六进制"></a>1.1.1 二进制、十六进制</h4>以2为基数的数制叫二进制，后缀用B表示，例如1000 1001B<br>以16为基数的数制叫十六进制，后缀用H表示，如果第一个数字是字母要加前缀0，例如：0AAH，19H<h4 id="1-1-2-一般进制转十进制"><a href="#1-1-2-一般进制转十进制" class="headerlink" title="1.1.2 一般进制转十进制"></a>1.1.2 一般进制转十进制</h4>利用以下公式：<br>$$ N=\sum_{i=-m}^{n=1} X_i*j^i$$<br>N表示十进制的值，Xi表示第i位系数，j表示数制的基数，$j^i$表示第i位的权<h4 id="1-1-3-二进制转十六进制"><a href="#1-1-3-二进制转十六进制" class="headerlink" title="1.1.3 二进制转十六进制"></a>1.1.3 二进制转十六进制</h4>每4位二进制转1位十六进制，例如：0010 1111B=2FH<h3 id="1-2-码制"><a href="#1-2-码制" class="headerlink" title="1.2 码制"></a>1.2 码制</h3>在计算机中有三种码，分别是原码，反码与补码。<br>存储在计算机中的数，一字节有8位，分为有符号数和无符号数，对于有符号数，在计算机中约定，最高位1表示负数，0表示正数，引入反码补码可以将减法变为加法，从而减轻电子电路的设计工作。<h3 id="1-2-1-反码补码的计算"><a href="#1-2-1-反码补码的计算" class="headerlink" title="1.2.1 反码补码的计算"></a>1.2.1 反码补码的计算</h3>对于一个正数，它的反码和补码等于它的原码<br>对于一个负数，它的反码等于这个数非符号位取反加符号位，它的补码等于反码加一<br>通过补码进行的计算，计算结果依旧是补码</li>
</ol>
<h3 id="1-2-2-BCD码"><a href="#1-2-2-BCD码" class="headerlink" title="1.2.2 BCD码"></a>1.2.2 BCD码</h3><p>就是只用0-9的二进制位表示，对于1010，1011，1100，1101，1110，1111这6个编码不用。<br>这样更加直观的表示，也节省硬件电路的转换时间。</p>
<h3 id="1-2-3-ASCII码"><a href="#1-2-3-ASCII码" class="headerlink" title="1.2.3 ASCII码"></a>1.2.3 ASCII码</h3><p>ASCII用7位二进制来表示，可以分为高3位组和低4位组，分别表示符号的列序和行序。</p>
<h2 id="结构及工作原理"><a href="#结构及工作原理" class="headerlink" title="结构及工作原理"></a>结构及工作原理</h2><p>MSC-51系列单片机为例</p>
<h3 id="2-1-内部部件"><a href="#2-1-内部部件" class="headerlink" title="2.1 内部部件"></a>2.1 内部部件</h3><p>51单片机内部结构包括：</p>
<ol>
<li>CPU<ol>
<li>运算器：包括ALU、布尔处理器、累加器ACC、寄存器B、暂存器TMP1、TMP2、程序状态字PSW，十进制调整电路</li>
<li>控制器</li>
</ol>
</li>
<li>内部存储器<ol>
<li>ROM：程序存储器，是只读存储器</li>
<li>RAM：数据存储器，随机存储器，又分为片内和片外。其中片内只有256B可用，其中高128B作为专用存储器，用户可用存储器只有128B。</li>
</ol>
</li>
<li>定时器：MCS-51有两个16位的定时器/计数器</li>
<li>中断系统控制器：有5个中断源，2个外部中断，定时中断2个，串行口中断1个</li>
<li>并行I/O口：有4个并行的8位I/O口，P0，P1，P2，P3</li>
<li>全双工串行口</li>
<li>OSC：是指单片机的时钟电路，一般典型的工作频率是6MHz和12MHz<h3 id="2-2-管脚作用"><a href="#2-2-管脚作用" class="headerlink" title="2.2 管脚作用"></a>2.2 管脚作用</h3><h3 id="2-3-不同结构"><a href="#2-3-不同结构" class="headerlink" title="2.3 不同结构"></a>2.3 不同结构</h3></li>
<li>哈佛结构</li>
<li>冯·诺伊曼结构</li>
</ol>
<h3 id="2-4-存储器编码逻辑"><a href="#2-4-存储器编码逻辑" class="headerlink" title="2.4 存储器编码逻辑"></a>2.4 存储器编码逻辑</h3><h4 id="2-4-1-程序存储器ROM"><a href="#2-4-1-程序存储器ROM" class="headerlink" title="2.4.1 程序存储器ROM"></a>2.4.1 程序存储器ROM</h4><p>有内部存储器4k，一般不需要外部ROM，编码也是直接从内部到外部，没用中间跳跃。</p>
<h4 id="2-4-2-数据存储器RAM"><a href="#2-4-2-数据存储器RAM" class="headerlink" title="2.4.2 数据存储器RAM"></a>2.4.2 数据存储器RAM</h4><p>80C51有256B的RAM，其中128B是特殊分别寄存器(SFR)，剩下的128B又分为三个部分，工作寄存器（32个字节，4组不同的工作寄存器，00H-1FH），位寻址区（16字节，20H-2FH，128位，后面128位用在SFR上了），开放区（80字节，30H-7FH）</p>
<h4 id="2-4-3-时钟与时序"><a href="#2-4-3-时钟与时序" class="headerlink" title="2.4.3 时钟与时序"></a>2.4.3 时钟与时序</h4><ol>
<li>振荡周期：晶体振动一次的时间</li>
<li>状态周期：两个振荡周期等一一个状态周期</li>
<li>机器周期：每6个状态周期一个机器周期</li>
<li>指令周期：1～4个机器周期（没有3机器周期的指令）</li>
</ol>
<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h3 id="3-1-指令系统基础"><a href="#3-1-指令系统基础" class="headerlink" title="3.1 指令系统基础"></a>3.1 指令系统基础</h3><p>机器语言-汇编-高级语言<br>全部指令的集合叫指令系统<br>80C51有111条指令，还有8条伪指令<br>指令分类：</p>
<ul>
<li>字节数分类<ul>
<li>单字节49 双字节46 三字节16</li>
</ul>
</li>
<li>运算数度分类<br>  -单周期64 双45 四周期2</li>
<li>功能<ul>
<li>数据传输 29</li>
<li>算数运算 24</li>
<li>逻辑运算 24</li>
<li>控制转移 17</li>
<li>布尔操作 17</li>
</ul>
</li>
</ul>
<h4 id="3-1-1-指令格式"><a href="#3-1-1-指令格式" class="headerlink" title="3.1.1 指令格式"></a>3.1.1 指令格式</h4><p>标号:操作码 &lt;&gt;,&lt;&gt;,&lt;&gt;;<br>操作数之间要有逗号<br>操作码：指令<br>标号是一个地址，指向程序的</p>
<h4 id="3-1-2-通用符号"><a href="#3-1-2-通用符号" class="headerlink" title="3.1.2 通用符号"></a>3.1.2 通用符号</h4><p>Rn 当前寄存器中的8个工作寄存器<br>Ri （i=0，1）可用作地址指针的2个<br>#data 包含在指令中的8位常数，无#是地址<br>#data16 16位常数<br>direct RAM中的地址<br>addr16 16位的目的地址，用于LCALL和LJMP中<br>rel 相对地址，也指标号<br>bit 位寻址的地址<br>@ 间接寻址方式中用于表示间址寄存器</p>
<h3 id="3-2-寻址方式"><a href="#3-2-寻址方式" class="headerlink" title="3.2 寻址方式"></a>3.2 寻址方式</h3><ol>
<li>立即寻址<br> 指令中有一个操作数为常数，能直接参与操作称为“立即数”<br> 在指令中，带#表示立即数，不带的表示位置</li>
<li>直接寻址<br> 指令中直接给出操作数的地址（）表示取地址中的数据</li>
<li>寄存器寻址<br> 指令当中的操作数在特殊寄存器，或工作寄存器中</li>
<li>寄存器间接寻址<br> 指令中的操作数的地址在寄存器中，寄存器前要加@符号<br> 可以作为间址寄存器的只有R0、R1、DPTR（16位的，对外扩展存贮器，只能用这玩意）（堆栈操作除外，SP）<br> e·g：<code>MOV A，@R0</code></li>
<li>变址寻址<br> 以16位寄存器PC或DPTR为基址寄存器，A为变址寄存器，将两者之和作为操作数的地址，（三条指令，都是ROM的地址）<br> <code>MOVC A，@A+PC；</code><br> <code>MOVC A，@A+DPTR；</code><br> <code>JMP @A+DPTR</code></li>
<li>相对寻址<br> 针对PC，在PC上的基础上给出额外的偏移量，用于短转移指令和条件转移指令。<br> <code>JC 03H</code></li>
<li>位寻址<br>直接按位寻址，例如<code>acc.7</code></li>
</ol>
<h3 id="3-3-数据传送指令"><a href="#3-3-数据传送指令" class="headerlink" title="3.3 数据传送指令"></a>3.3 数据传送指令</h3><ol>
<li>内部数据传送指令MOV<br>MOV&lt;目的操作数&gt;,&lt;源操作数&gt;<ul>
<li>以累加器A为目的的操作数的数据传送指令<ul>
<li><code>MOV A,#data;</code></li>
<li><code>MOV A,Direct;</code>寄存器地址或者I/O口的</li>
<li><code>MOV A,Rn;</code></li>
<li><code>MOV A,@Ri;</code></li>
</ul>
</li>
<li>以寄存器Rn为目的操作室的数据传送指令<ul>
<li>不可以MOV Rn,Rn;</li>
<li>其余和A寄存器指令类似</li>
</ul>
</li>
<li>以RAM或端口直接地址为目的操作数的数据传送指令<ul>
<li><code>MOV direct,A;</code></li>
<li><code>MOV direct,Rn;</code></li>
<li><code>MOV direct,#data;</code></li>
<li><code>MOV direct1,direct2;</code>这句很特殊，机器码是先放direct2（机器码是逆序）</li>
<li><code>MOV direct,@Ri;</code></li>
</ul>
</li>
<li>以间接地址为目的操作数的数据传输指令<ul>
<li><code>MOV @Ri,A;</code></li>
<li><code>MOV @Ri,direct;</code></li>
<li><code>MOV @Ri,#data;</code></li>
</ul>
</li>
<li>16位数据传输指令<ul>
<li><code>MOV DPTR,#data16;</code>是一个片内操作，唯一一条16位</li>
</ul>
</li>
</ul>
</li>
<li>查表指令MOVC(针对程序存储器ROM)<br>MOVC&lt;目的操作&gt;,&lt;源操作数&gt;；MOV CODE<ul>
<li><code>MOVC A,@A+PC;</code>变址寻址</li>
<li><code>MOVC A,@A+DPTR;</code>变址寻址</li>
</ul>
</li>
<li>片外数据传送MOVX（片外RAM只能通过间接寻址）<br>MOVX&lt;目的操作数&gt;&lt;源操作数&gt;;<ul>
<li><code>MOVX A,@DPTR;</code>16位，数据8位（外面到里面）</li>
<li><code>MOVX @DPTR,A;</code>片外寻址范围64KB（里面到外面）</li>
<li><code>MOVX A,@Ri;</code></li>
<li><code>MOVX @Ri,A;</code></li>
</ul>
</li>
<li>堆栈操作数<br>堆栈的工作原理：后入先出原则。实际的堆栈是一种逻辑运用<br>有一个SP（stack point）的指针SFR中的8位寄存器，里面的地址指向栈顶，最后入堆栈的数据。复位上电后SP默认指向07H<ul>
<li><code>MOV SP,#6FH;</code>设置堆栈从70H开始区域最低地址减一</li>
<li><code>PUSH direct；</code>ACC是A的地址；</li>
<li><code>POP direct；</code></li>
</ul>
</li>
<li>数据交换指令<ul>
<li><code>XCH A,Rn;</code></li>
<li><code>XCH A,direct;</code></li>
<li><code>XCH A,@Ri;</code></li>
<li><code>XCHD A,@Ri;</code>换低四位</li>
<li><code>SWAP A;</code>A的低高4位互换</li>
</ul>
</li>
</ol>
<h3 id="3-4-算数运算指令"><a href="#3-4-算数运算指令" class="headerlink" title="3.4 算数运算指令"></a>3.4 算数运算指令</h3><p>这类指令主要是对8位数进行加减乘除，除了加一减一指令，运算结果将影响PSW的标志位CY，AC，OV</p>
<h4 id="3-4-1-加法指令"><a href="#3-4-1-加法指令" class="headerlink" title="3.4.1 加法指令"></a>3.4.1 加法指令</h4><p>ADD，ADDC，INC</p>
<ol>
<li>不带进位的加法指令ADD，累加器A与操作数相加，相加结果只能放在累加器A中<ul>
<li><code>ADD A,RN;</code></li>
<li><code>ADD A,direct;</code></li>
<li><code>ADD A,@Ri;</code></li>
<li><code>ADD A,#data;</code><br>注意：有符号数加数或被加数为负数时，需要放置该负数的补码；结果为负数时，A中为该负数的结果的补码<br>8位无符号数（0～255），8位有符号数（-128～+127）（因为10000001是-127的补码，所约定10000000是-128，00000000是0，状态一直都是256的状态）<br>/无符号数用CY=1表示和溢出（把CY看成第九位）<br>\有符号数用OV=1表示和溢出<br>/若bit7和bit6有且仅有一位进位，OV=1，否则OV=0<br>\若bit3有进位，AC=1，反正AC=0（压缩BCD码）</li>
</ul>
</li>
<li>带进位的加法指令ADDC累加A与操作数以及CY相加<ul>
<li><code>ADDC A,Rn;</code></li>
<li><code>ADDC A,direct;</code></li>
<li><code>ADDC A,@Ri;</code></li>
<li><code>ADDC A,#data;</code><br>可以用来做多字节相加</li>
</ul>
</li>
<li>自加1的指令INC（不影响标志位）<ul>
<li><code>INC A;</code></li>
<li><code>INC Rn;</code></li>
<li><code>INC direct;</code></li>
<li><code>INC @Ri;</code></li>
<li><code>INC DPTR;</code>有进位自己会处理<br>数据首部是字母要加一个0表示是数不是变量<br>单片机做的运算和有符号数无符号数无关，这是程序员来处理的</li>
</ul>
</li>
</ol>
<h4 id="3-4-2-减法指令"><a href="#3-4-2-减法指令" class="headerlink" title="3.4.2 减法指令"></a>3.4.2 减法指令</h4><p>SUBB DEC</p>
<ol>
<li>带借位的减法 A与操作数相减，再减CY<ul>
<li><code>SUBB A,Rn;</code></li>
<li><code>SUBB A,direct;</code></li>
<li><code>SUBB A,@Ri;</code></li>
<li><code>SUBB A,#data;</code><br>bit7借位CY=1<br>bit3有借位AC=1<br>bit7bit6有且只有一位借位，OV=1</li>
</ul>
</li>
<li>自减1指令DEC不影响标志位<ul>
<li><code>DEC A;</code></li>
<li><code>DEC Rn;</code></li>
<li><code>DEC direct;</code></li>
<li><code>DEC @Rn;</code></li>
</ul>
</li>
</ol>
<h4 id="3-4-3-乘法"><a href="#3-4-3-乘法" class="headerlink" title="3.4.3 乘法"></a>3.4.3 乘法</h4><ul>
<li><code>MUL AB；</code>A&lt;-AxB低八位，B&lt;-AxB高八位<br>只对于累加器A和B寄存器的无符号数<br>运算结果两个字节，低位放在A中，高位存在B中<br>运算结果大于00FFH，OV=1，否则OV=0。CY一定被清零，不影响AC<br>只占一个字节，速度是4个机器周期<h4 id="3-4-4-除法"><a href="#3-4-4-除法" class="headerlink" title="3.4.4 除法"></a>3.4.4 除法</h4></li>
<li><code>DIV AB;</code>A/B，A中是商，B中是余数<br>B=0 OV=1，否则OV等于0，CY一定被清零，不影响AC</li>
</ul>
<h4 id="3-4-5-十进制调整指令"><a href="#3-4-5-十进制调整指令" class="headerlink" title="3.4.5 十进制调整指令"></a>3.4.5 十进制调整指令</h4><ul>
<li><code>DA A；</code><br>若A的低四位&gt;9或AC=1，则A+06H<br>若A的高四位&gt;9或CY=1，则A+60H<br>只用于压缩BCD码加法运算后的调整<br>指令用在ADD和ADDC后不影响标志位，<br>不可以在SUBB后用</li>
</ul>
<h3 id="3-5-逻辑操作指令"><a href="#3-5-逻辑操作指令" class="headerlink" title="3.5 逻辑操作指令"></a>3.5 逻辑操作指令</h3><p>与、或、异或、清除、移位、取反，操作不影响标志位</p>
<ol>
<li>与<ul>
<li><code>ANL A,Rn;</code></li>
<li><code>ANL A,direct;</code></li>
<li><code>ANL A,@Ri;</code></li>
<li><code>ANL A,#data;</code></li>
<li><code>ANL direct,A;</code></li>
<li><code>ANL direct,#data;</code></li>
</ul>
</li>
<li>或<ul>
<li><code>ORL A,Rn;</code></li>
<li><code>ORL A,direct;</code></li>
<li><code>ORL A,@Ri;</code></li>
<li><code>ORL A,#data;</code></li>
<li><code>ORL direct,A;</code></li>
<li><code>ORL direct,#data;</code></li>
</ul>
</li>
<li>异或<ul>
<li><code>XRL A,Rn;</code></li>
<li><code>XRL A,direct;</code></li>
<li><code>XRL A,@Ri;</code></li>
<li><code>XRL A,#data;</code></li>
<li><code>XRL direct,A;</code></li>
<li><code>XRL direct,#data;</code></li>
</ul>
</li>
<li>取反、清零<ul>
<li><code>CPL A;</code>取反</li>
<li><code>CLR A;</code>清零</li>
</ul>
</li>
<li>循环移位指令<ul>
<li><code>RL A;</code>累加器A左移位，乘2</li>
<li><code>RR A;</code>累加器A右移位，除以2</li>
<li><code>RLC A;</code>累加A带进位左移位，借助多字节的整体左移位</li>
<li><code>RRC A;</code>累加A带进位右移位</li>
</ul>
</li>
</ol>
<h3 id="3-6-控制转移指令"><a href="#3-6-控制转移指令" class="headerlink" title="3.6 控制转移指令"></a>3.6 控制转移指令</h3><p>该类指令控制PC</p>
<ol>
<li>无条件转移指令<ul>
<li><code>LJMP addr16;</code>长转移 PC指向addr16 实现64K范围内程序转移</li>
<li><code>AJMP addr11;</code>绝对转移，双字节指令，指令取出后PC+2，之后PC高5位不变，低11位被addr11覆盖（2K范围，基于AJMP执行后的PC+2）</li>
<li><code>SJMP rel;</code>相对转移，双字节，相对于指令执行之前的PC，执行后PC=PC+2+rel。rel是有符号数，范围-128+～128</li>
</ul>
</li>
<li>条件转移<ul>
<li><code>JN rel;</code>A=0</li>
<li><code>JNZ rel;</code>A!=0</li>
<li><code>CJNE A,direct,rel;</code>jump if not equal，操作数1&gt;=操作数2 CY=0，反之CY=1</li>
<li><code>CJNE A,#data,rel</code></li>
<li><code>CJNE Rn,#data,rel</code></li>
<li><code>CJNE @Ri,#data,rel</code></li>
<li><code>DJNZ Rn,rel;</code>不影响标志位</li>
<li><code>DJNZ direct,rel</code></li>
</ul>
</li>
<li>间接转移指令<ul>
<li><code>JMP @A+DPTR</code></li>
</ul>
</li>
<li>子程序调用及返回指令<ul>
<li><code>LCALL addr16;</code>PC=PC+3 PC所指的16位地址入栈 同时堆栈指针SP=SP+2</li>
<li><code>ACALL addr11;</code></li>
<li><code>RET；</code>子程序返回指令。用于子程序的末尾</li>
<li><code>RETI;</code>中断服务子程序返回指令，中断不是设定的，是事件触发，外部0，1，timer0，1，串口通信 5个中断地址0000H，0003H，000BH，00013H，001BH，0023H</li>
</ul>
</li>
<li>空操作指令<ul>
<li><code>NOP；</code>消耗一个周期</li>
</ul>
</li>
</ol>
<h3 id="3-7-位操作指令"><a href="#3-7-位操作指令" class="headerlink" title="3.7 位操作指令"></a>3.7 位操作指令</h3><p>包括位传送、位逻辑运算、位控制<br>位地址的表达防方式</p>
<ol>
<li>直接使用位地址，范围00H～FFH 前128个在20H～2FH，高128在SFR</li>
<li>字节**<em>.</em>位序号可访问，如PSW。5、P0.7 20H.7，acc.7</li>
</ol>
<p>位操作指令</p>
<ol>
<li>位数据传送<ul>
<li><code>MOV C,bit;</code>C是CY，有点像A</li>
<li><code>MOV bit,C;</code>把c移入bit</li>
</ul>
</li>
<li>位修改指令<ul>
<li><code>CLR C</code> 设置CY=0</li>
<li><code>CLR bit</code></li>
<li><code>SETB C</code>设置为1</li>
<li><code>SETB bit</code></li>
<li><code>CPL C</code>取反操作</li>
<li><code>CPL bit</code></li>
</ul>
</li>
<li>位的逻辑运算指令<ul>
<li><code>ANL C,bit</code></li>
<li><code>ANL C,/bit</code></li>
<li><code>ORL C,bit</code></li>
<li><code>ORL C,/bit</code></li>
</ul>
</li>
<li>位转移指令<ul>
<li><code>JC rel;</code>C=1转到rel</li>
<li><code>JNC rel;</code>C=0转</li>
<li><code>JB bit,rel;</code>bit=1转到rel</li>
<li><code>JNB bit rel;</code>bit=0转到</li>
<li><code>JBC bit,rel;</code></li>
</ul>
</li>
</ol>
<h3 id="3-8-伪指令"><a href="#3-8-伪指令" class="headerlink" title="3.8 伪指令"></a>3.8 伪指令</h3><ul>
<li><code>ORG</code> 改变程序存放位置</li>
<li><code>END</code> 后的程序之后就不会被编译了</li>
<li><code>EQU</code> 赋值伪指令  <code>X1 EQU 50H；</code>把50H命名为X1</li>
<li><code>DB</code> 定义字节</li>
<li><code>DW</code> 定义字，两个字节16位，低地址存放高字节，高地址存饭低字节</li>
<li><code>BIT</code> 位地址赋值 <code>L0 BIT 10H</code>表示10H位地址命名为L0</li>
<li><code>DATA</code> </li>
</ul>
<h2 id="汇编语言程序设计"><a href="#汇编语言程序设计" class="headerlink" title="汇编语言程序设计"></a>汇编语言程序设计</h2><p>利用上述指令系统完成程序的编程</p>
<h3 id="4-1-顺序程序"><a href="#4-1-顺序程序" class="headerlink" title="4.1 顺序程序"></a>4.1 顺序程序</h3><p>正常的顺序执行代码即可</p>
<h3 id="4-2-分支程序"><a href="#4-2-分支程序" class="headerlink" title="4.2 分支程序"></a>4.2 分支程序</h3><p>通过判断语句完成不同情况的跳转，在程序中一直都是顺序执行的，但是可以用跳转指令完成语句跳跃。</p>
<h3 id="4-3-循环程序"><a href="#4-3-循环程序" class="headerlink" title="4.3 循环程序"></a>4.3 循环程序</h3><p>同上，用跳转指令完成跳转就可以</p>
<h3 id="4-4-查表程序"><a href="#4-4-查表程序" class="headerlink" title="4.4 查表程序"></a>4.4 查表程序</h3><p>在ROM中先定义一些结果，单遇到对应输入的时候直接在ROM中查询结果就可以，查表程序可以用PC做为基或DPTR做为基</p>
<h3 id="4-5-子程序"><a href="#4-5-子程序" class="headerlink" title="4.5 子程序"></a>4.5 子程序</h3><p>用LCALL和RET搭配完成子程序的调用，其原理是在SP堆栈中存入了对应指令的地址，通过压入和弹出返回原调用位置，如果不使用RET用别的跳转指令也可以实现。</p>
<h2 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h2><p>方法并不惟一，有更好的方法，仅做参考。</p>
<h4 id="把单片机片内的30H～7FH-单元清零"><a href="#把单片机片内的30H～7FH-单元清零" class="headerlink" title="把单片机片内的30H～7FH 单元清零"></a>把单片机片内的30H～7FH 单元清零</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        ORG 0000H</span><br><span class="line">CLEAR:  MOV R0,#30H     ;30H 送R0寄存器</span><br><span class="line">        MOV R6,#50H     ;50H 送R6寄存器（用作计数器）</span><br><span class="line">CLR1:   MOV A,#18H  ;18 送累加器A</span><br><span class="line">        MOV @R0,A       ;00 送到30H-7FH 单元</span><br><span class="line">        INC R0          ;R0 加1</span><br><span class="line">        DJNZ R6,CLR1    ;不到50H个字节，继续</span><br><span class="line">WAIT:   LJMP WAIT</span><br><span class="line">        END</span><br></pre></td></tr></table></figure>
<h4 id="片外RAM中1000H～100FH单元中的数传送到片外RAM中2000H～200FH单元"><a href="#片外RAM中1000H～100FH单元中的数传送到片外RAM中2000H～200FH单元" class="headerlink" title="片外RAM中1000H～100FH单元中的数传送到片外RAM中2000H～200FH单元"></a>片外RAM中1000H～100FH单元中的数传送到片外RAM中2000H～200FH单元</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         ORG 0000H</span><br><span class="line">         MOV DPTR,#1000H</span><br><span class="line">         MOV R0,#40H</span><br><span class="line">MOVE1:   MOVX A,@DPTR</span><br><span class="line">         MOV @R0,A</span><br><span class="line">         INC R0</span><br><span class="line">         INC DPTR</span><br><span class="line">         CJNE R0,#50H,MOVE1</span><br><span class="line">         MOV DPTR,#2000H</span><br><span class="line">         MOV R0,#40H</span><br><span class="line">MOVE2:   MOV A,@R0</span><br><span class="line">         MOVX @DPTR,A</span><br><span class="line">         INC R0</span><br><span class="line">         INC DPTR</span><br><span class="line">         CJNE R0,#50H,MOVE2</span><br><span class="line">         END</span><br></pre></td></tr></table></figure>
<h4 id="以PC为基址寄存器，查表求30H单元中BCD码的平方，结果存入31H单元"><a href="#以PC为基址寄存器，查表求30H单元中BCD码的平方，结果存入31H单元" class="headerlink" title="以PC为基址寄存器，查表求30H单元中BCD码的平方，结果存入31H单元"></a>以PC为基址寄存器，查表求30H单元中BCD码的平方，结果存入31H单元</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org 0000h  </span><br><span class="line">mov a,30h</span><br><span class="line">add a,#05h</span><br><span class="line">movc a,@a+pc</span><br><span class="line">mov 31H,a</span><br><span class="line">wait: ljmp wait</span><br><span class="line">tab:db 0,1,4,9,16,25,36,49,64,81</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="2字节无符号数转换成BCD码"><a href="#2字节无符号数转换成BCD码" class="headerlink" title="2字节无符号数转换成BCD码"></a>2字节无符号数转换成BCD码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        ORG 0000H       ;get 2bit into BCD 30H,31H,6-&gt;40H,41H,42H,43H,44H,45H</span><br><span class="line">        MOV R1,#40H</span><br><span class="line">CLR1:   MOV @R1,#00H</span><br><span class="line">        INC R1</span><br><span class="line">        CJNE R1,#46H,CLR1</span><br><span class="line">        MOV R6,30H      ;count</span><br><span class="line">        MOV A,31H       ;A&#x3D;F7H</span><br><span class="line">        MOV B,#100      ;B&#x3D;100</span><br><span class="line">        DIV AB          ;A&#x2F;B A&#x3D;2,B&#x3D;47</span><br><span class="line">        MOV 42H,A       ;42H&#x3D;2</span><br><span class="line">        MOV A,B         ;A&#x3D;47</span><br><span class="line">        MOV B,#10       ;B&#x3D;10</span><br><span class="line">        DIV AB          ;A&#x2F;B A&#x3D;4,B&#x3D;7</span><br><span class="line">        MOV 41H,A       ;41H&#x3D;4</span><br><span class="line">        MOV 40H,B       ;40H&#x3D;7</span><br><span class="line">ADDEE:  MOV A,#06H      ;A&#x3D;6</span><br><span class="line">        ADD A,40H       ;A&#x3D;A+40H&#x3D;13</span><br><span class="line">        MOV B,#10       ;B&#x3D;10</span><br><span class="line">        DIV AB          ;A&#x2F;B,A&#x3D;1,B&#x3D;3</span><br><span class="line">        MOV 40H,B       ;40H&#x3D;B&#x3D;3</span><br><span class="line">        MOV 50H,A       ;50H&#x3D;1</span><br><span class="line">        MOV A,#05H      ;A&#x3D;5</span><br><span class="line">        ADD A,41H       ;A&#x3D;A+41H&#x3D;5+4&#x3D;9</span><br><span class="line">        ADD A,50H       ;A&#x3D;A+50H&#x3D;9+1&#x3D;10</span><br><span class="line">        MOV B,#10       ;B&#x3D;10</span><br><span class="line">        DIV AB          ;A&#x2F;B,A&#x3D;1,B&#x3D;0</span><br><span class="line">        MOV 41H,B       ;41H&#x3D;0</span><br><span class="line">        MOV 50H,A</span><br><span class="line">        MOV A,#02H      ;A&#x3D;2</span><br><span class="line">        MOV B,#10       ;B&#x3D;10</span><br><span class="line">        ADD A,42H       ;A&#x3D;A+42H&#x3D;2+2&#x3D;4</span><br><span class="line">        ADD A,50H       ;A&#x3D;A+50H&#x3D;4+1&#x3D;5</span><br><span class="line">        MOV B,#10</span><br><span class="line">        DIV AB          ;A&#x3D;0,B&#x3D;5</span><br><span class="line">        MOV 50H,A       ;50H&#x3D;0</span><br><span class="line">        MOV 42H,B       ;42H&#x3D;5</span><br><span class="line">        MOV R1,#43H     ;R1&#x3D;43H</span><br><span class="line">HADD:   MOV A,@R1       ;A&#x3D;(43H)</span><br><span class="line">        ADD A,50H       ;A&#x3D;A+50H</span><br><span class="line">        MOV B,#10       ;B&#x3D;10</span><br><span class="line">        DIV AB          ;A&#x2F;B</span><br><span class="line">        MOV @R1,B</span><br><span class="line">        MOV 50H,A</span><br><span class="line">        INC R1</span><br><span class="line">        CJNE R1,#46H,HADD</span><br><span class="line">        DJNZ R6,ADDEE</span><br><span class="line">WAIT:   LJMP    WAIT</span><br><span class="line">        END</span><br></pre></td></tr></table></figure>

<h4 id="将一个字节中的各位逆序排列"><a href="#将一个字节中的各位逆序排列" class="headerlink" title="将一个字节中的各位逆序排列"></a>将一个字节中的各位逆序排列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        org 0000h       ;</span><br><span class="line">        mov 30h,#82h    ;82h&#x3D;10000010b 0100 0001b&#x3D;41h</span><br><span class="line">        mov a,30h</span><br><span class="line">        mov 31h,#00h</span><br><span class="line">        mov r3,#08h     ;count&#x3D;8</span><br><span class="line">push1:</span><br><span class="line">        mov c,acc.0     ;</span><br><span class="line">        rr a</span><br><span class="line">        mov 30h,a</span><br><span class="line">        mov a,31h</span><br><span class="line">        rlc a           ;</span><br><span class="line">        mov 31h,a</span><br><span class="line">        mov a,30h</span><br><span class="line">        djnz r3,push1</span><br><span class="line">wait:   ljmp wait       ;</span><br><span class="line">        end</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建相册</title>
    <url>/2020/04/18/Hexo%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%86%8C/</url>
    <content><![CDATA[<h1 id="Hexo-NexT主题搭建博客相册"><a href="#Hexo-NexT主题搭建博客相册" class="headerlink" title="Hexo-NexT主题搭建博客相册"></a>Hexo-NexT主题搭建博客相册</h1><p>想着怎么可以给主页搭建一个相册提供图片分享，但我对前端知识一无所知，在查看了好多<a href="https://blog.csdn.net/qq_31279347/article/details/82427533" target="_blank" rel="noopener">大佬的博客</a>后，借大佬的前端代码经过一些配置后总算是实现了。但是还是有一些问题。</p>
<a id="more"></a>

<h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><p>大概就是要解决两件事，一件是图片资源怎么放到网上，二是个人主页怎么调用资源。因为使用的是GitHub Page搭建的个人主页，每个git仓库只有1G的大小，放图片的话容量显得有些捉襟见肘，所以很多博客也推荐，把图片和网页分开存放。可以使用的云存储可以有如下一些</p>
<ul>
<li><a href="https://github.com" target="_blank" rel="noopener">GitHub</a></li>
<li><a href="https://www.aliyun.com/product/oss?utm_content=se_1005589194" target="_blank" rel="noopener">阿里云OSS</a></li>
<li><a href="https://www.qiniu.com" target="_blank" rel="noopener">七牛云</a></li>
<li><a href="https://cloud.tencent.com" target="_blank" rel="noopener">腾讯云</a></li>
<li><a href="https://cloud.tencent.com/product/coding" target="_blank" rel="noopener">coding.me</a>和腾讯云是一起的</li>
</ul>
<p>以上这些作为图床各有优缺点，其中GitHub，coding是免费且不需要实名的，七牛云强制实名认证，但是实名后有10G的容量，阿里云和腾讯云属于需要付费使用。</p>
<p>我选择的是GitHub，在GitHub上再开一个仓库用来存放图片。但是GitHub有一个问题，它作为资源服务的raw.githubusercontent.com服务被中国墙了，所以目前需要查看我的图片必须通过科学上网。<br>(不过也有博客说是由于DNS污染的原因，但是小菜鸟现在还不懂这些，之后会试着解决一下)</p>
<p><strong>raw.githubusercontent.com和GitHub</strong><br>raw.githubusercontent.com是github 的素材服务器 (assets server), 分开存放避免跟主服务抢占负载。</p>
<p>选好图床了，接下来就是下载代码和配置，可以参考<a href="https://blog.csdn.net/qq_31279347/article/details/82427533" target="_blank" rel="noopener">大佬的博客</a>,主要是这样几个步骤</p>
<ol>
<li>GitHub上的配置</li>
<li>Hexo-next配置</li>
</ol>
<h2 id="GitHub配置"><a href="#GitHub配置" class="headerlink" title="GitHub配置"></a>GitHub配置</h2><p>建立一个新的仓库，选择公开，然后把网址复制下来。<br>在自己喜欢的地方建一个文件夹(album)，进入终端，确保自己电脑上已经有git的情况下输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd album</span><br><span class="line">mkdir photos</span><br><span class="line">git init</span><br><span class="line">git clone githubaddress ;把建好的仓库拷贝下来</span><br><span class="line">git remote add origin yourrepositroy@gitaddress ;与刚刚建好的库建立远端链接</span><br></pre></td></tr></table></figure>
<p>把自己想放上去的图片重新以YY-MM-DD_des.jpg的格式命名，放到photos文件夹<br>复制<a href="https://github.com/malizhigithub/HexoAlbumData" target="_blank" rel="noopener">这个项目</a>中的tool.py到ablum文件夹中,注意修改json文件的生成路径。<br>运行tool.py文件，如果报错检查相关依赖包是否都安装完成（比如PIL图像处理库）<br>tool.py会自己把图片剪裁，压缩，保存json文件，并且推送到远端的GitHub仓库中<br>tool.py文件中有一处代码有些奇怪，我自己进行的一些修改以保证它的正确运行，是针对其中的compress_photo函数，修改为下面代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress_photo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''调用压缩图片的函数</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    src_dir, des_dir = <span class="string">"photos/"</span>, <span class="string">"min_photos/"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> directory_exists(src_dir):</span><br><span class="line">        <span class="comment">#if not directory_exists(src_dir):</span></span><br><span class="line">        make_directory(src_dir)</span><br><span class="line">        <span class="comment"># business logic</span></span><br><span class="line">    file_list_src = list_img_file(src_dir)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> directory_exists(des_dir):</span><br><span class="line">        <span class="comment">#if not directory_exists(des_dir):</span></span><br><span class="line">        make_directory(des_dir)</span><br><span class="line">    file_list_des = list_img_file(des_dir)</span><br><span class="line">        <span class="comment"># print file_list</span></span><br><span class="line">    <span class="string">'''如果已经压缩了，就不再压缩'''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(file_list_des)):</span><br><span class="line">        <span class="keyword">if</span> file_list_des[i] <span class="keyword">in</span> file_list_src:</span><br><span class="line">            file_list_src.remove(file_list_des[i])</span><br><span class="line">    compress(<span class="string">'1'</span>, des_dir, src_dir, file_list_src)</span><br></pre></td></tr></table></figure>

<p><strong>远程仓库push出现问题</strong><br>第一次运行tool文件时在git推送远端的时候报错（不好意思忘记截图了）<br>大概错误是分支冲突的感觉所以我使用了git pull命令，但是还是没有解决<br>查了一些方法后，可以通过如下操作强行将远端和本地统一，这样就不会冲突，在进行add和commit就不会出问题了，shell的代码如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories;强制统一</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>如果<code>git pull</code>出现如下报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: You have not concluded your merge (MERGE_HEAD exists).</span><br><span class="line">hint: Please, commit your changes before merging.</span><br><span class="line">fatal: Exiting because of unfinished merge.</span><br></pre></td></tr></table></figure>
<p>可以通过一下git代码放弃本地修改来解决</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure>


<h2 id="Hexo-next配置"><a href="#Hexo-next配置" class="headerlink" title="Hexo-next配置"></a>Hexo-next配置</h2><p>分显示配置和资源配置</p>
<h3 id="建立新的Page"><a href="#建立新的Page" class="headerlink" title="建立新的Page"></a>建立新的Page</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 你的博客文件夹</span><br><span class="line">hexo new page photos</span><br></pre></td></tr></table></figure>
<p>在theme/hexo-theme-next/_config.yml中的menu中新建一个photos栏（需要中文翻译的话，需要去，theme/hexo-theme-next/languages/zh-CN.yml中添加对应字段）</p>
<p>然后在source/photos/index.md中复制入如下代码（我暂时还不是很理解，大概就是分快和调用了json文件）</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 图片</span><br><span class="line">date: </span><br><span class="line">type: "photos"</span><br><span class="line">fancybox: false</span><br><span class="line">comments: true</span><br><span class="line">---</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"../lib/album/ins.css"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"../lib/album/photoswipe.css"</span>&gt;</span></span> </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"../lib/album/default-skin/default-skin.css"</span>&gt;</span></span> </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"photos-btn-wrap"</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"photos-btn active"</span> <span class="attr">href</span>=<span class="string">"javascript:void(0)"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"external"</span>&gt;</span></span>分栏<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"instagram itemscope"</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"修改成你自己的网址"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">class</span>=<span class="string">"open-ins"</span>&gt;</span></span>图片正在加载中…<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line">  (function() &#123;</span><br><span class="line"><span class="code">    var loadScript = function(path) &#123;</span></span><br><span class="line"><span class="code">      var $script = document.createElement('script')</span></span><br><span class="line"><span class="code">      document.getElementsByTagName('body')[0].appendChild($script)</span></span><br><span class="line"><span class="code">      $script.setAttribute('src', path)</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    setTimeout(function() &#123;</span></span><br><span class="line"><span class="code">        loadScript('../lib/album/ins.js')</span></span><br><span class="line"><span class="code">    &#125;, 0)</span></span><br><span class="line">  &#125;)()</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="配置资源调用"><a href="#配置资源调用" class="headerlink" title="配置资源调用"></a>配置资源调用</h3><p>然后在theme/hexo-theme-next/source/lib/album(自己建一个)，把json文件放入，同时把<a href="https://github.com/malizhigithub/HexoAlbumData" target="_blank" rel="noopener">项目</a>的JS&amp;CSS文件夹下的所有文件拷贝到其中。<br>针对刚刚拷入的文件，其中的ins.js文件，修改其中的两行为(可以用ctrl+F)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSrc = <span class="string">'https://raw.githubusercontent.com/yourgithub/repository/master/min_photos/'</span> + data.link[i];        </span><br><span class="line"><span class="keyword">var</span> src = <span class="string">'https://raw.githubusercontent.com/yourgithub/repository/master/photos/'</span> + data.link[i];</span><br></pre></td></tr></table></figure>
<p>最后把photoswipe-ui-default.min.js, photoswipe.min.js两个文件添加到themes/hexo-theme-next/source/js/src中。（没有src文件夹自己建一个就行）</p>
<p>以上资源配置完成</p>
<h3 id="配置查看图片插件"><a href="#配置查看图片插件" class="headerlink" title="配置查看图片插件"></a>配置查看图片插件</h3><p>在hexo-theme-next/layout/_layout.swig的头部前添加对js文件的引用如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"&#123;&#123; url_for(theme.js) &#125;&#125;/src/photoswipe.min.js?v=&#123;&#123; theme.version &#125;&#125;"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="&#123;&#123; url_for(theme.js) &#125;&#125;/</span>src/photoswipe-ui-<span class="keyword">default</span>.min.js?v=&#123;&#123; theme.version &#125;&#125;<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>在body部分添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> page.type === <span class="string">"photos"</span> %&#125;</span><br><span class="line">  &lt;!-- Root element <span class="keyword">of</span> PhotoSwipe. Must have <span class="class"><span class="keyword">class</span> <span class="title">pswp</span>. --&gt;</span></span><br><span class="line"><span class="class">  &lt;<span class="title">div</span> <span class="title">class</span></span>=<span class="string">"pswp"</span> tabindex=<span class="string">"-1"</span> role=<span class="string">"dialog"</span> aria-hidden=<span class="string">"true"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"pswp__bg"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="pswp__scroll-wrap"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="pswp__container"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="pswp__item"&gt;&lt;/</span>div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"pswp__item"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="pswp__item"&gt;&lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="pswp__ui pswp__ui--hidden"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="pswp__top-bar"&gt;</span></span><br><span class="line"><span class="regexp">                &lt;div class="pswp__counter"&gt;&lt;/</span>div&gt;</span><br><span class="line">                &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"pswp__button pswp__button--close"</span> title=<span class="string">"Close (Esc)"</span>&gt;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button class="pswp__button pswp__button--share" title="Share"&gt;&lt;/</span>button&gt;</span><br><span class="line">                &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"pswp__button pswp__button--fs"</span> title=<span class="string">"Toggle fullscreen"</span>&gt;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button class="pswp__button pswp__button--zoom" title="Zoom in/</span>out<span class="string">"&gt; </span></span><br><span class="line"><span class="string">                &lt;/button&gt;</span></span><br><span class="line"><span class="string">                &lt;!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR --&gt;</span></span><br><span class="line"><span class="string">                &lt;!-- element will get class pswp__preloader--active when preloader is running --&gt;</span></span><br><span class="line"><span class="string">                &lt;div class="</span>pswp__preloader<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                    &lt;div class="</span>pswp__preloader__icn<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                      &lt;div class="</span>pswp__preloader__cut<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                        &lt;div class="</span>pswp__preloader__donut<span class="string">"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">                      &lt;/div&gt;</span></span><br><span class="line"><span class="string">                    &lt;/div&gt;</span></span><br><span class="line"><span class="string">                &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div class="</span>pswp__share-modal pswp__share-modal--hidden pswp__single-tap<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                &lt;div class="</span>pswp__share-tooltip<span class="string">"&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;button class="</span>pswp__button pswp__button--arrow--left<span class="string">" title="</span>Previous (arrow left)<span class="string">"&gt;</span></span><br><span class="line"><span class="string">            &lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;button class="</span>pswp__button pswp__button--arrow--right<span class="string">" title="</span>Next (arrow right)<span class="string">"&gt;</span></span><br><span class="line"><span class="string">            &lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;div class="</span>pswp__caption<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                &lt;div class="</span>pswp__caption__center<span class="string">"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<p>配置就基本完成了(原博客中还有部分配置，但next主题更新后有些配置文件找不到了，我发现不进行也没有影响)</p>
<h2 id="之后做些啥"><a href="#之后做些啥" class="headerlink" title="之后做些啥"></a>之后做些啥</h2><p>这次相册的配置主要是对流程的熟悉过程，大概了解是如果进行分资源存放。<br>这个相册的效果是ins的风格，我更愿意使用类似瀑布流形式的图片UI，所以之后应该会参考别的博客对UI进行一些改变，还有就是raw.githubusercontent.com国内无法访问的问题，也许需要更改存放资源的位置。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_31279347/article/details/82427533" target="_blank" rel="noopener">利用Github实现Hexo博客相册</a></li>
<li><a href="https://blog.csdn.net/u013082989/article/details/70162293" target="_blank" rel="noopener">Hexo+Github实现相册功能</a></li>
<li><a href="https://timding.top/2017/09/18/Hexo-NexT-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%86%8C-%E4%BA%8C/" target="_blank" rel="noopener">Tim’sBlog</a></li>
<li><a href="https://github.com/malizhigithub/HexoAlbumData" target="_blank" rel="noopener">github/HexoAlbumData</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2020/04/06/git/</url>
    <content><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>git是一种分布式版本控制方法。git可以高效的控制管理代码，完善恢复，帮助完成团队合作的任务。它记录的是修改记录，而不是文件。这也使的它可以在本地进行高效的版本控制，文章简单介绍git的使用方法，非常基础简单，仅供参考。</p>
<a id="more"></a>

<h2 id="创建自己的git仓库"><a href="#创建自己的git仓库" class="headerlink" title="创建自己的git仓库"></a>创建自己的git仓库</h2><p>首先要在自己的电脑上安装好git库，参考网上教程吧。可以在<a href="https://git-scm.com/" target="_blank" rel="noopener">官方网站</a>下载，安装。<br>安装好后，电脑上建立一个文件夹，从终端进入文件夹，输入代码<code>git init</code>就创建了一个git仓库。这个文件夹就被初始化成一个git仓库了。之后在这个文件夹进行的文件操作会被git所记录。</p>
<h2 id="把东西搬到仓库里"><a href="#把东西搬到仓库里" class="headerlink" title="把东西搬到仓库里"></a>把东西搬到仓库里</h2><p>简单的说，git管理中有三个区域，分别是工作区，暂存区，储存区。这三个区并不是指切实的在硬盘上划分出来的区域，而是指某一文件的状态。工作区是对当前文件进行修改的状态，暂存区是将工作区文件的修改记录记下来，储存区就是将暂存区的许多文件打包成一个版本存下记录。</p>
<p>用<code>git add filename</code>把文件放入暂存区，可以使用<code>git status</code>查看当前工作区和暂存区的文件内容。使用<code>git commit -m&quot;介绍&quot;</code>创建版本快照，完整的放入存储室。这样就完成了一次提交，使用<code>git log</code>就可以查看到提交情况。</p>
<h2 id="查看自己的仓库"><a href="#查看自己的仓库" class="headerlink" title="查看自己的仓库"></a>查看自己的仓库</h2><p><code>git log</code>可以查看自己的仓库库存，可以加入<code>--pretty==oneline</code> 使显示变的亲和一些。</p>
<h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>可以使用<code>git tag&lt;name&gt;</code>对生成的版本进行打标签工作。可以用<code>git tag -d &lt;name&gt;</code>删除标签。</p>
<p>引出分支：<code>git branch branchname</code>这样会创建一个branchname的分支。<br>查看分支：<code>git branch</code>这样可以直接查看分支。<br>切换分支：<code>git switc branchname</code><br>合并分支：<code>git merge branchname</code><br>删除分支：<code>git branch -d branchname</code></p>
<p>当有一个版本后，git鼓励在分支上工作，等调试完了在并入主支，分支功能也是高效合作的关键功能。<br>版本回退：<code>git reset --hard HEAD^</code>表示回退到上一个版本，回退几个版本就加几个^。<br>指令记录查看：<code>git reflog</code>可以查看进行过的指令，这里可以找到被调整过的版本号。</p>
<p>查看变化：<code>git diff HEAD -- file</code>可以查看file工作区与版本库之间的差别。</p>
<p>撤销修改：<code>git checkout --file</code>可以撤销做的文件修改。</p>
<h2 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h2><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><p>配置git用户名：<code>git config --global user.name &quot;name&quot;</code><br>配置git邮箱：<code>git config --global user.email &quot;email&quot;</code><br>查看git用户名：<code>git config --global user.name</code><br>查看git邮箱：<code>git config --global user.email</code></p>
<p>查看全局配置：<code>git config --global --list</code><br>查看本地配置：<code>git config --local --list</code><br>查看全部配置：<code>git config --list</code><br>设置git彩色ui特性：<code>git config --global color.ui true</code>（但是我没有成功过hhh，展示不知道怎么回事）</p>
<h3 id="管理代码类"><a href="#管理代码类" class="headerlink" title="管理代码类"></a>管理代码类</h3><p>工作区的文件加到暂存区：<code>git add filename</code><br>添加所有被tracked的文件的修改到暂存区：<code>git add -u</code><br>添加所有tracked文件修改和没修改文件和untracked文件：<code>git add -A</code><br>将当前工作区的所有文件都加入暂存区：<code>git add .</code><br>进入交互界面模式，按需添加文件到缓存区：<code>git add -i</code></p>
<p>暂存区提交到本地仓库：<code>git commit -m</code><br>直接提交到仓库：<code>git commit -a -m</code></p>
<p>查看git管理状态：<code>git status</code><br>修改文件名字：<code>git rm filename</code></p>
<h3 id="调用版本、分支管理"><a href="#调用版本、分支管理" class="headerlink" title="调用版本、分支管理"></a>调用版本、分支管理</h3><p><code>git diff</code><br><code>git diff branchname</code><br><code>git diff HEAD</code><br><code>git diff id path</code><br><code>git diff --stage</code><br><code>git diff TAG</code><br><code>git diff branchA branchB</code><br>跳转到此分支：<code>git checkout -b dev</code><br>新建分支并跳转到此分支：<code>git branch dev</code><br>查看分支：<code>git checkout dev</code><br>查看分支：<code>git branch</code><br>合并分支：<code>git merge dev</code><br>回退版本：<code>git reset HEAD^</code><br>查看历史命令：<code>git reflog</code><br>回退到指定版本：<code>git reset --hard 版本号</code></p>
<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p><code>git tag &lt;name&gt;</code><br><code>git tag</code><br><code>git show &lt;tagname&gt;</code><br><code>git tag -a v0.1 -m</code><br><code>git tag -l &lt;版本号&gt;</code></p>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><code>git log</code><br><code>git log -p -times</code><br><code>git log --stat</code><br><code>git log --name-only</code><br><code>git log -oneline</code><br><code>git log --graph --all --oneline</code><br><code>git log filename</code></p>
<h3 id="远端git交互"><a href="#远端git交互" class="headerlink" title="远端git交互"></a>远端git交互</h3><p>把本地仓库代码推送到远端：<code>git push -u origin master</code><br>将远端代码下载到本地仓库：<code>git clone</code></p>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p>GitHub是最大的代码托管中心。可以将自己的代码托管在这个网站上（简单说相当于是给自己的代码提供了一个云盘存放，当然GitHub本身其实是有很多很方便的特性）。<br>.io库，是github提供的一个服务器，相当于一个静态网页代码的托管，可以用它完成个人主页的创建，之后会有专门的文章记录我的个人主页创建过程。</p>
<p>文章之后还会慢慢修改补充，当前只整理了这些。<br>感谢大佬的教程相助！</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>markdown语法基础</title>
    <url>/2020/04/06/markdown/</url>
    <content><![CDATA[<h1 id="markdown-语法基础"><a href="#markdown-语法基础" class="headerlink" title="markdown 语法基础"></a>markdown 语法基础</h1><p>介绍基础的markdown语法以及常用数学表达式的latex编辑方法。</p>
<a id="more"></a>
<h2 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1.基础语法"></a>1.基础语法</h2><ol>
<li><p>六级标题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">####</span><br><span class="line">#####</span><br><span class="line">######</span><br></pre></td></tr></table></figure>
</li>
<li><p>有序列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 你要写的东西</span><br><span class="line">2. 你要写的东西</span><br><span class="line">3. 你要写的东西</span><br></pre></td></tr></table></figure></li>
<li><p>无序列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 一级无序列表</span><br><span class="line">  - 二级无序列表</span><br><span class="line">    - 三级无序</span><br><span class="line">- 一级无序列表</span><br></pre></td></tr></table></figure>
<p>这样就会显示</p>
</li>
</ol>
<ul>
<li>一级无序列表<ul>
<li>二级无序列表<ul>
<li>三级无序</li>
</ul>
</li>
</ul>
</li>
<li>一级无序列表 </li>
</ul>
<ol start="4">
<li>表格写法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|表头|表头|表头|</span><br><span class="line">|:---:|:---|---:|</span><br><span class="line">|居中|左对齐|右对齐|</span><br></pre></td></tr></table></figure>
会显示如下</li>
</ol>
<table>
<thead>
<tr>
<th align="center">表头</th>
<th align="left">表头</th>
<th align="right">表头</th>
</tr>
</thead>
<tbody><tr>
<td align="center">居中</td>
<td align="left">左对齐</td>
<td align="right">右对齐</td>
</tr>
</tbody></table>
<p>貌似这里没有解析出来，尴尬</p>
<ol start="5">
<li>常见渲染方式<br><em>斜体</em>      <code>*斜体*</code><br><strong>加粗</strong>    <code>**加粗**</code><br><strong><em>加粗斜体</em></strong><code>***加粗斜体***</code><br>==背景色==  <code>==背景色==</code><br><del>删除线</del><code>~~删除线~~</code><br>A<del>下标</del> A^上标^<code>~下标~^上标^</code><br>角注[^1]<code>角注[^1]</code><br>$下标<em>{下标}$`$下标</em>{下标}$<code>$上标_{上标}$</code>$上标_{上标}$`</li>
</ol>
<h2 id="2-数学表达式"><a href="#2-数学表达式" class="headerlink" title="2. 数学表达式"></a>2. 数学表达式</h2><h3 id="2-1-积分类"><a href="#2-1-积分类" class="headerlink" title="2.1 积分类"></a>2.1 积分类</h3><p>积分：<code>$\int$</code>$\int$</p>
<p>二重积分：<code>$\iint$</code>$\iint$</p>
<p>三重积分：<code>$\iiint$</code>$\iiint$</p>
<p>环积分：<code>$\oint$</code>$\oint$</p>
<p>二重环积分：<code>$\oiint$</code> (没有正确渲染)</p>
<p>三重环积分：<code>$\oiiint$</code>（没有正确渲染）</p>
<h3 id="2-2-其他"><a href="#2-2-其他" class="headerlink" title="2.2 其他"></a>2.2 其他</h3><p>求和号：<code>$\sum$</code>$\sum$</p>
<p>极限号：<code>$\lim$</code>$\lim$</p>
<p>分数：<code>$\frac{a}{b}$</code>$\frac{a}{b}$</p>
<p>向量：<code>$\vec{d}$</code>$\vec{d}$</p>
<p>奇怪字体：<code>$\frak{uu}$</code>$\frak{uu}$</p>
<p>大于等于：<code>$\ge$</code>$\ge$</p>
<p>远大于：<code>$\gg$</code>$\gg$</p>
<p>点圈：<code>$\odot$</code>$\odot$</p>
<p>约等于：<code>$\approx$</code>$\approx$</p>
<p>交集：<code>$\cap$</code>$\cap$</p>
<p>点积：<code>$\cdot$</code>$\cdot$</p>
<p>省略号：<code>$\cdots$</code>$\cdots$</p>
<p>之后会慢慢补充，希望对您有帮助～</p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCv基础(1)</title>
    <url>/2020/04/15/opencv/</url>
    <content><![CDATA[<h1 id="OpenCv基础（一）"><a href="#OpenCv基础（一）" class="headerlink" title="OpenCv基础（一）"></a>OpenCv基础（一）</h1><p>Opencv是开源的跨平台计算机视觉库。它是轻量级并且高效的，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。目前版本已经迭代到opencv4.2。<br><a href="https://baike.baidu.com/item/opencv/10320623" target="_blank" rel="noopener">OpenCv 百度百科</a></p>
<a id="more"></a>
<h2 id="opencv-python-安装"><a href="#opencv-python-安装" class="headerlink" title="opencv python 安装"></a>opencv python 安装</h2><p>用conda下载安装相关库就可以了<br><code>conda install opencv</code><br><a href="https://opencv.org" target="_blank" rel="noopener">OpenCv官网</a></p>
<h2 id="opencv-python的使用基础"><a href="#opencv-python的使用基础" class="headerlink" title="opencv python的使用基础"></a>opencv python的使用基础</h2><p>在使用使，需要import相关库，之后的代码默认已经有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matlabplot           <span class="comment">#数据处理，matlab绘图接口库</span></span><br></pre></td></tr></table></figure>
<p><strong>怎么读取并显示一张图片</strong><br>使用imread和imshow</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取图片</span></span><br><span class="line">img=cv2.imread(<span class="string">"img_path"</span>,<span class="number">0</span>)  <span class="comment">#文件路径，读取img,0是读取方式，表示读取灰度图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示图片</span></span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)     <span class="comment">#‘image’是窗口名，输出img</span></span><br><span class="line"><span class="comment">#等价的显示方法</span></span><br><span class="line">plt.imshow(img, cmap = <span class="string">'gray'</span>, interpolation = <span class="string">'bicubic'</span>)<span class="comment">#以灰度图像显示图片</span></span><br><span class="line">plt.xticks([]), plt.yticks([]) <span class="comment">#隐藏x,y轴</span></span><br><span class="line">plt.show()                     <span class="comment">#显示图片</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存图片</span></span><br><span class="line">cv2.imwrite(<span class="string">"img.jpg"</span>,img)</span><br></pre></td></tr></table></figure>

<p><strong>怎么读取视屏</strong><br>在opencv中，视频也是一帧一帧被读取的，称为视频流。代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建了一个cap视频流</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)<span class="comment">#- 0 本机摄像头- 1 外接摄像头</span></span><br><span class="line"><span class="comment">#修改视频流参数</span></span><br><span class="line">cap.get(propId) <span class="comment">#读取参数</span></span><br><span class="line">    <span class="comment">#其中propId=3表示每一帧高</span></span><br><span class="line">    <span class="comment">#其中propId=4表示每一帧高</span></span><br><span class="line">cap.set(propId,value) <span class="comment">#修改参数</span></span><br><span class="line"><span class="comment">#视频流初始化</span></span><br><span class="line"><span class="comment">#cap.isOpened()</span></span><br><span class="line">cap.read()</span><br><span class="line"><span class="comment">#保存视频流</span></span><br><span class="line">fourcc = cv2.cv.FOURCC(*<span class="string">'XVID'</span>) <span class="comment">#定义格式</span></span><br><span class="line">out = cv2.VideoWriter(<span class="string">'output.avi'</span>,fourcc, <span class="number">20.0</span>, (<span class="number">640</span>,<span class="number">480</span>))<span class="comment">#定义一个输出文件</span></span><br><span class="line"><span class="comment">#循环读取图片（帧）</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># Capture frame-by-frame</span></span><br><span class="line">    ret, frame = cap.read()<span class="comment">#返回一个布尔值(True/False)</span></span><br><span class="line">    <span class="comment"># Our operations on the frame come here</span></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) </span><br><span class="line">    <span class="comment">#转换颜色空间* cv2.COLOR_BGR2GRAY</span></span><br><span class="line">    <span class="comment"># Display the resulting frame</span></span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>,gray) 显示视频流</span><br><span class="line">    out.write(frame)<span class="comment">#把frame写入文件，这个要放在while循环中</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>): <span class="comment">#表示当你按下键盘q时break</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment">#释放保存文件空间</span></span><br><span class="line">out.release()</span><br><span class="line"><span class="comment">#释放视频流</span></span><br><span class="line">cap.release()</span><br></pre></td></tr></table></figure>

<h2 id="opencv的GUI特性"><a href="#opencv的GUI特性" class="headerlink" title="opencv的GUI特性"></a>opencv的GUI特性</h2><h3 id="绘图函数"><a href="#绘图函数" class="headerlink" title="绘图函数"></a>绘图函数</h3><p><strong>基本参数</strong></p>
<ul>
<li>img:你想要绘制图形的那幅图像。</li>
<li>color:形状的颜色。以RGB为例，需要传入一个元组，例如:(255,0,0)代表蓝色。对于灰度图只需要传入灰度值。</li>
<li>thickness:线条的粗细。如果给一个闭合图形设置为-1，那么这个图形就会被填充。默认值是1</li>
<li>linetype:线条的类型，8连接，抗锯齿等。默认情况是8连接。<ul>
<li>cv2.LINE_AA为抗锯齿，这样看起来会非常平滑</li>
</ul>
</li>
</ul>
<p><strong>函数</strong></p>
<ul>
<li>cv2.line() 画直线<pre><code>- 给起点终点</code></pre></li>
<li>cv2.circle() 画圆<pre><code>- 给中心和半径</code></pre></li>
<li>cv2.rectangle() 画矩形（感觉用的最多了）<pre><code>- 给左上和右下</code></pre></li>
<li>cv2.ellipse()画椭圆<pre><code>- 给长轴和短轴旋转角度</code></pre></li>
<li>cv2.putText()<ul>
<li>文字</li>
<li>位置</li>
<li>字体</li>
<li>大小</li>
<li>颜色等属性</li>
</ul>
</li>
<li>cv2.polylines() 可以被用来画很多条线</li>
</ul>
<h3 id="鼠标与事件"><a href="#鼠标与事件" class="headerlink" title="鼠标与事件"></a>鼠标与事件</h3><p>opencv捕获事件函数<br>    * cv2.setMouseCallback(‘image’,draw_circle)<br>    * cv2.waitKey(20)&amp;0xFF==27</p>
<p><strong>如何查询事件</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#opencv查表</span></span><br><span class="line">events=[i <span class="keyword">for</span> i <span class="keyword">in</span> dir(cv2) <span class="keyword">if</span> <span class="string">'EVENT'</span><span class="keyword">in</span> i]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">        - 事件查阅</span></span><br><span class="line"><span class="string">        - cv2.EVENT_LBUTTONDOWN</span></span><br><span class="line"><span class="string">        - cv2.EVENT_MOUSEMOVE</span></span><br><span class="line"><span class="string">        - cv2.EVENT_FLAG_LBUTTON</span></span><br><span class="line"><span class="string">        - cv2.EVENT_LBUTTONUP</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机视觉</tag>
        <tag>opencv</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>专利申请和文件撰写</title>
    <url>/2020/04/06/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E5%92%8C%E6%96%87%E4%BB%B6%E6%92%B0%E5%86%99/</url>
    <content><![CDATA[<h1 id="专利申请文件"><a href="#专利申请文件" class="headerlink" title="专利申请文件"></a>专利申请文件</h1><h2 id="1-文件构成"><a href="#1-文件构成" class="headerlink" title="1.文件构成"></a>1.文件构成</h2><p>对于专利发明和实用新型需要包括</p>
<a id="more"></a>
<ul>
<li>请求书</li>
<li>权利要求书</li>
<li>说明书</li>
<li>说明书附图</li>
<li>摘要</li>
</ul>
<p>对于外观设计专利需要包括</p>
<ul>
<li>请求书</li>
<li>外观设计的图片和照片</li>
<li>简要说明</li>
</ul>
<h3 id="1-1请求书"><a href="#1-1请求书" class="headerlink" title="1.1请求书"></a>1.1请求书</h3><h3 id="1-2说明书"><a href="#1-2说明书" class="headerlink" title="1.2说明书"></a>1.2说明书</h3><p>说明书是专利申请文件的核心，是权利要求书的依据，为权利要求书提供解释</p>
<h3 id="1-3权利要求书"><a href="#1-3权利要求书" class="headerlink" title="1.3权利要求书"></a>1.3权利要求书</h3><p>权利要求书分为两类</p>
<ul>
<li>产品权利要求书</li>
<li>方法权利要求书</li>
</ul>
<p>撰写中权利要求书中使用的科技术语应当与说明书中使用的一致，可以有化学式或数学式， 必要时可以有表格，但不得有插图。不得使用“如说明书……部分所述”或者“如图……所示”等用语。</p>
<p>权利要求的概念：</p>
<ol>
<li>并列独立权利<br>并列独立权利要求:产品、制造产品的方法，产品的用途，制造产品的设备;方法，为该方法设计 的设备。与产品描述是相互独立、并列的。可以理解为权利要求分成总分(并列独立权利)分(从属权利 要求)结构。例(沿用之前铅笔的例子):一种如权利要求 1 所述铅笔的加工方法，其特征在于:在加工过 程中在铅笔的末端固定一个橡皮。</li>
<li>独立权利<br>独立权利要求:独立权利要求从总体上体现发明构思，保护范围最大。解决问题的不可缺少的技术特征、相对于现有技术具有新颖性和创造性。可以通过列写出发明所有的技术 特征，删去非必要技术特征、与发明不相干的特征实现。</li>
<li>从属权利<br>从属权利要求:为独立权利 要求做限定的、附加的技术特征，构建多层保护体系。示例:根据权利要求 1 所属的汽车，其特征在于， 所述合金材料为不锈钢<h4 id="1-3-1产品权利要求书"><a href="#1-3-1产品权利要求书" class="headerlink" title="1.3.1产品权利要求书"></a>1.3.1产品权利要求书</h4>包括：物品、物质、材料、工具、 装置、设备等<br>产品权利要求需要说明产品的技术特征:零件、元器件、部件、材料、器具、设备的形状、结构尺寸; 产品元素、含量等等。示例:一种汽车，包括底盘，其特征在于底盘由合金材料制成。<h4 id="1-3-2方法权利要求书"><a href="#1-3-2方法权利要求书" class="headerlink" title="1.3.2方法权利要求书"></a>1.3.2方法权利要求书</h4>包括制造方法，使用方法，通讯方法，处理方法，将产品适用于特定用途 的方法</li>
</ol>
<h2 id="撰写"><a href="#撰写" class="headerlink" title="撰写"></a>撰写</h2><h3 id="权利要求书的撰写"><a href="#权利要求书的撰写" class="headerlink" title="权利要求书的撰写"></a>权利要求书的撰写</h3><p>权利要求撰写步骤</p>
<ol>
<li>找出主要特征，弄清关系、作用;</li>
<li>根据现有特征确定必要技术特征;</li>
<li>比较现有技术找到共同必要技术和特征;</li>
<li>分析附加技术特征，将附加技术特征写入从权。</li>
</ol>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>专利申请</tag>
      </tags>
  </entry>
  <entry>
    <title>心理学导论-条件反射和学习</title>
    <url>/2020/04/06/%E5%BF%83%E7%90%86%E5%AD%A6%E5%AF%BC%E8%AE%BA-%E6%9D%A1%E4%BB%B6%E5%8F%8D%E5%B0%84%E5%92%8C%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="心理学导论——条件反射和学习"><a href="#心理学导论——条件反射和学习" class="headerlink" title="心理学导论——条件反射和学习"></a>心理学导论——条件反射和学习</h1><h2 id="学习的定义"><a href="#学习的定义" class="headerlink" title="学习的定义"></a>学习的定义</h2><p>学习是由经验引起的相对持久的行为变化。</p>
<p>经典条件反射：形成取决于一个反应前发生的事<br>操作性条件反射：建立在反应结果的基础上，结果决定反应是否再次发生</p>
<a id="more"></a>
<h3 id="经典条件反射"><a href="#经典条件反射" class="headerlink" title="经典条件反射"></a>经典条件反射</h3><p>经典条件反射，人们会学会刺激与反应的关系建立，基础是人的非条件反射，通过条件刺激在非条件刺激周围徘徊，可以使条件刺激与非条件反应建立联系，从而实现条件反射。<br>习得：条件刺激在无条件刺激前出现，紧密，很快就会习得<br>期望：认知会建立新的心理期望<br>消退：条件反射是会消退的<br>自动恢复：消退不是一次性完成的，中间会有反复<br>泛化：将刺激广泛的应用到别的联系上<br>辨别：出现类似刺激，在多次训练不同强化后会辨别不同刺激的结果，也是泛化消退</p>
<p>人类的条件反射和情绪<br>条件性情绪反射：经历后，人们会形成反射<br>间接性情绪反射：听说后人们也会建立情绪反射</p>
<h3 id="操作性条件反射"><a href="#操作性条件反射" class="headerlink" title="操作性条件反射"></a>操作性条件反射</h3><p>这是一种把行为和结果联系起来的反射。（是人们认为这个操作可以对应一个结果，这个结果决定这个操作再发生的可能性）</p>
<p>习得：也叫强化，通过调整结果，改变以拥有技能的出现频次，强化的时间要在正确反应后的较短时间内。但是人有期望性，所以也没关系。</p>
<p>操作性条件反射可以解释迷信行为，即在结果和正确反应之间有别的动作参与，我们认为这个反应是正确的并也得到了强化。</p>
<p>强化方式有正强化和负强化<br>正强化：反应得到的结果是愉快的<br>负强化：反应得到的结果是结束不愉快的<br>其实我个人感觉差不多，都是向好的。</p>
<p>强化还可以通过惩罚和反应代价实现<br>惩罚：反应得到的结果是不愉快的<br>反应代价：反应得到的结果是结束愉快<br>这两个我个人感觉是向负的</p>
<p>操作性消退：同样需要时间，也会反复</p>
<p>操作性强化物：分为一级、二级强化物、反馈<br>一级强化物：指具有生理基础，满足生理需要<br>二级强化物：有习得性，可以和一级挂钩（比如钱），有比一级强化性更长的强化效应<br>反馈：给人信息来强化行为</p>
<p>部分强化：相对连续强化，多次反应后再给出结果，有不同的间隔模式，比如：固定比率FR，不定比率VR，固定时间FI，不定时间VI<br>VR模式比FR更不容易消退，同样VI也有更好的抑制消退的效果</p>
<h4 id="惩罚"><a href="#惩罚" class="headerlink" title="惩罚"></a>惩罚</h4><p>惩罚的正确应用：要有一致性、及时性、适度<br>惩罚的副作用：对惩罚者的情绪恶意、产生逃避反应、攻击性上升</p>
<h3 id="其他学习方式"><a href="#其他学习方式" class="headerlink" title="其他学习方式"></a>其他学习方式</h3><p>认知学习：就是我们说的理解的学，包括潜在学习、发现式学习也是理解学习的方式。<br>榜样学习：通过观察加模仿</p>
]]></content>
      <categories>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>心理学导论—知觉</title>
    <url>/2020/04/06/%E5%BF%83%E7%90%86%E5%AD%A6%E5%AF%BC%E8%AE%BA-%E7%9F%A5%E8%A7%89/</url>
    <content><![CDATA[<h1 id="心理学导论——知觉"><a href="#心理学导论——知觉" class="headerlink" title="心理学导论——知觉"></a>心理学导论——知觉</h1><h4 id="1-知觉的恒常性"><a href="#1-知觉的恒常性" class="headerlink" title="1. 知觉的恒常性"></a>1. 知觉的恒常性</h4><p>知觉有：大小恒常性、形状恒常性、亮度恒常性</p>
<h4 id="2-知觉的组织性"><a href="#2-知觉的组织性" class="headerlink" title="2. 知觉的组织性"></a>2. 知觉的组织性</h4><p>人们按照格式塔原则进行知觉组织，原则包含一下规则：</p>
<a id="more"></a>
<ul>
<li>邻近原则</li>
<li>相似性原则</li>
<li>连续性原则</li>
<li>闭合原则</li>
<li>接近原则</li>
<li>同域原则</li>
</ul>
<p>利用与工程设计中，好的设计应该符合人的自然知觉</p>
<h4 id="3-深度知觉"><a href="#3-深度知觉" class="headerlink" title="3.深度知觉"></a>3.深度知觉</h4><p>深度知觉是指可以感受图像中物体深度的能力，对其是否先天具有，不同心理学家有不同观点，普遍认为，深度知觉有后天习得也有先天基础。4个月大的婴儿逐渐出现有深度感知。</p>
<h5 id="成年人的深度知觉"><a href="#成年人的深度知觉" class="headerlink" title="成年人的深度知觉"></a>成年人的深度知觉</h5><p>人们通过包括环境特征和内部肌肉消息判断深度。按参与的眼睛数量不同线索分为单眼线索和双眼线索。</p>
<ul>
<li>肌肉线索：来自肌体内部，比如晶状体的调节，在1.2米内晶状体的弯曲聚焦，使之弯曲的肌肉的感觉会被传递大大脑中帮助判断，这种调节属于单眼线索</li>
<li>辐合：来自肌体，在15米外，双眼必须向内汇聚以对准物体，这种调节是双眼调节</li>
<li>立体视觉：利用视网膜像差</li>
</ul>
<p>可以通过人为线索使人有深度感，立体感，这种图形深度线索包括</p>
<ul>
<li>线条透视</li>
<li>相对大小</li>
<li>图中位置</li>
<li>阴影</li>
<li>遮挡</li>
<li>纹理梯度</li>
<li>空气透视</li>
<li>运动视差（严格来说不算图像深度线索，但是会引起深度知觉）</li>
</ul>
<h4 id="4-知觉学习"><a href="#4-知觉学习" class="headerlink" title="4.知觉学习"></a>4.知觉学习</h4><p>知觉习惯：习得因素对知觉的影响很大，人们有一定的知觉习惯，比如看倒立的脸人们就不能很好的组织人脸。很多视错觉便是基于人们的知觉习惯出现的。<br>适应水平：刺激所在的环境背景也会影响知觉，这种背景可以是类似与经验一样的东西。<br>错觉：可能原因是基于人们在生活中的各种常识和知觉习惯，还有恒常性等等。</p>
<h4 id="5-知觉与动机"><a href="#5-知觉与动机" class="headerlink" title="5.知觉与动机"></a>5.知觉与动机</h4><p>注意：在许多的感觉中，人们会选择其中一部分作知觉感受，这种选择性使人们从感觉到知觉的通道狭窄。<br>某些刺激更容易引起人们的注意：</p>
<ul>
<li>强度</li>
<li>重复</li>
<li>变化</li>
</ul>
<p>习惯化：接受某信息后产生的反应，为定向反应，多次刺激后，定向反应会减弱。（逐渐不敏感）（对于创造力强的人，习惯化速度往往比别人慢）<br>（禅宗大师没有表现出对刺激的习惯化）<br>动机：想什么就会注意什么</p>
<h4 id="6-期望性知觉"><a href="#6-期望性知觉" class="headerlink" title="6.期望性知觉"></a>6.期望性知觉</h4><p>人的知觉有自上而下的组织或自下而上的组织<br>知觉定势：由于外界因素是人用一种特定的方式进行感知，形成知觉期望，人的知觉有可能被期望所改变。知觉期望经常是通过暗示形成的。<br>类别定势：比如看错形近字<br>人的知觉有很大程度上会被期望影响，眼见不一定为实。</p>
<h4 id="去习惯化"><a href="#去习惯化" class="headerlink" title="去习惯化"></a>去习惯化</h4><ul>
<li>知觉不是事实，是重组后的事实（严谨性）</li>
<li>打破知觉习惯，不受习惯化影响（换一换角度）</li>
<li>有意识的调整适应水平（多试试不同的东西）</li>
<li>克服知觉定势（独立化）</li>
<li>养成不断检验准确性的习惯（严谨性）</li>
<li>注意（集中注意力）</li>
</ul>
]]></content>
      <categories>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言基础</title>
    <url>/2020/04/07/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="汇编语言基础"><a href="#汇编语言基础" class="headerlink" title="汇编语言基础"></a>汇编语言基础</h1><p>汇编语言是对机器语言的符号化标记</p>
<a id="more"></a>
<h2 id="hello-world汇编"><a href="#hello-world汇编" class="headerlink" title="hello world汇编"></a>hello world汇编</h2><p>以下代码是16位的汇编程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data segment                            ;这里是变量定义段</span><br><span class="line">hello db &quot;Hello,world!&quot;,0Dh,0Ah,&quot;$&quot;     ;定义了一个db类型的变量，变量名是hello</span><br><span class="line">data segment end                        ;变量定义结束</span><br><span class="line"></span><br><span class="line">code segment                            ;代码段</span><br><span class="line">assume cs:code,ds:data                  ;指示代码段地址cs，变量段地址ds</span><br><span class="line">main:                                   ;主函数</span><br><span class="line">    mov ax,data;                        ;把变量段地址赋值给寄存器ax</span><br><span class="line">    mov ds,ax                           ;把变量段地址赋值给ds</span><br><span class="line">    mov ah,9                            ;ax寄存器的高8位赋值9</span><br><span class="line">    mov dx offset hello                 ;dx寄存器 offset是表示后面是参数</span><br><span class="line">    int 21h                             ;调用一次21h函数集</span><br><span class="line">    mov ah,4Ch                          ;将ax高8位ah赋值4Ch</span><br><span class="line">    int 21h                             ;再次调用21h函数集</span><br><span class="line">code ends                               ;代码段结束</span><br><span class="line">end main                                ;main函数结束（不参与编译）</span><br></pre></td></tr></table></figure>

<p>所以，一段汇编程序，包含两个大段，分别是data段和code段<br>data段：用data segment开头，data segment end结尾，用于保存变量<br>code段：代码写入的位置<br>assume：用于告诉编译器去哪里找段地址，其中code段地址自动赋值给cs，但是data段地址需要用户自己设置，不然就会乱。</p>
<p><strong><em>汇编的语句</em></strong><br>汇编的语句往往以以下形式出现<br><code>操作码 &lt;目的操作数&gt;，&lt;源操作数&gt;</code><br>进行操作后往往数字会被保存在目的操作数中。<br>汇编操作码也分单目多目，表示对多少个操作数进行操作</p>
<p><strong><em>$ax=ah+al$</em></strong><br>在16位汇编中，寄存器是16位的，可以分为高低8位，分别用ah，al来表示，即ax high，ax low。所以ax=ah+al。同理也可以有bx=bh+bl</p>
<p><strong><em>为什么有段地址</em></strong><br>在电脑中，这个段地址可以想象成是在电脑内存里面挖了一个仓库出来，然后把变量存进去。访问变量的时候，需要段地址加上偏移量，比如ds:[偏移量]这样来访问一个变量。同时注意，段地址不会自动赋值，所以需要用户自己对段地址进行赋值操作。定义的data段地址后才可以进行变量访问</p>
<p><strong><em>16位汇编和32位汇编64位汇编的区别</em></strong><br>16位的data段开头使用的是data segment，并且有data segment end结尾，而32位使用.data表示data段的开头。<br>在16位中寄存器的名字位ax，bx，cx等两个字母表示的16位的寄存器，在32位中则用eax，ebx等三个字节表示的32位寄存器。</p>
<p><strong><em>16位汇编的手动编译过程</em></strong></p>
<ol>
<li>在记事本等编辑软件中写好源代码，命名后缀为.ASM</li>
<li>将文件复制到doxbox86/masm文件夹中</li>
<li>打开doxbox86.exe，点击file-&gt;exit退出集成环境</li>
<li>命令行中输入masm filename;</li>
<li>输入link filename;</li>
<li>输入filename可以运行文件</li>
<li>输入td filename;可以进行调试</li>
</ol>
<p><strong><em>main函数</em></strong><br>不一定要叫main函数，爱叫啥叫啥，但是开头是什么，结尾的end后面也要是什么，要对应起来才行。</p>
<p><strong><em>int21h函数集</em></strong><br>是内置的函数集，使用方法参考中断大全。关于中断大全的使用方法：例如输入2109表示查int 21h的09h功能，2102表示int 21h的2号功能</p>
<p><strong><em>assume的作用</em></strong><br>帮助编译器建立段寄存器和段的关联，但是不能代替赋值，code的段地址默认会被赋值到cs中，但是data的段地址不会被默认送入ds，需要程序员手工进行赋值</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在汇编程序中可以用关键字定义不同长度的变量</p>
<p><strong><em>db</em></strong> ：表示define bit 定义1字节变量，8位<br><strong><em>dw</em></strong> ：表示define word 定义2字节变量，16位<br><strong><em>dd</em></strong> ：表示define double 定义4字节变量，32位<br><strong><em>dq</em></strong> ：表示define quadruple word 定义8字节变量，64位</p>
<p><strong><em>如何在16位汇编中使用32位寄存器</em></strong><br>在data前面加一个.386，表示cpu是80386以上的，在data segment 和 code segment 后边要加一个use16；表示使用16位地址偏移。这样就可以使用eax等32位寄存器，此时，eax的低16位是ax，高16位没有定义名字。</p>
<p><strong><em>小端规则</em></strong><br>在Inter系列的cpu中，常用的是小端规则。<br>小端规则是指，在保存多字节数字时，高位的地址在后，低位的地址在前。例如<br>定义一个 long int a=0x12345678<br>假设a的首地址是1000</p>
<table>
<thead>
<tr>
<th>地址</th>
<th align="center">小端规则</th>
<th align="center">大端规则</th>
</tr>
</thead>
<tbody><tr>
<td>1000</td>
<td align="center">0x78</td>
<td align="center">0x12</td>
</tr>
<tr>
<td>1001</td>
<td align="center">0x56</td>
<td align="center">0x34</td>
</tr>
<tr>
<td>1002</td>
<td align="center">0x34</td>
<td align="center">0x56</td>
</tr>
<tr>
<td>1003</td>
<td align="center">0x12</td>
<td align="center">0x78</td>
</tr>
</tbody></table>
<p><strong><em>零扩充和符号扩充</em></strong><br>当长度短的数变长度长的数时，如果是无符号数，那么多出来的位用零来填充，不管原来是什么类型的数，如果是有符号数，则如果原数是正数补零，原数是负数补一。</p>
<p><strong><em>小数的存储</em></strong><br>遵循IEEE754标准<br>我们以单精度float类型的32位小数为例子，4个字节如下分割。</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>10100110</td>
<td>10101010</td>
<td>10011101</td>
<td>01010101</td>
</tr>
</tbody></table>
<p>其中第一位是符号位，之后连续的8位是偏置指数位，再后面的23位是尾数位</p>
<table>
<thead>
<tr>
<th>符号位</th>
<th>偏置指数位</th>
<th>尾数</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>01001101</td>
<td>01010101001110101010101</td>
</tr>
<tr>
<td>1</td>
<td>8</td>
<td>23</td>
</tr>
</tbody></table>
<p>其中偏置指数位表的2进制值转化为10进制后要减去127才是真正的偏置指数的值$n$，这个值表示这个小数是$2^n$<br>尾数的值是在原尾数左侧加一个小数点，再加一个1<br>即：1.01010101001110101010101<br>得到的尾数和偏置指数的乘积就是这个小数的绝对值，在考虑符号位。<br>尾数要和偏置指数相乘，相当于尾数前后移动n位。<br>编程时十六进制常数时，如果刚好开头是字母，要加前缀0</p>
<h3 id="四则运算指令"><a href="#四则运算指令" class="headerlink" title="四则运算指令"></a>四则运算指令</h3><p>四则运算指令中，源操作数的长度要和目标操作数一样长。<br>运算指令分为：</p>
<ul>
<li>add 加</li>
<li>sub 减</li>
<li>mul 乘</li>
<li>div 除、求余</li>
</ul>
<p><strong>add、sub</strong><br>加减有着相似的语法规则。以加法为例</p>
<ul>
<li>add 寄存器,寄存器<code>add ax,bx</code></li>
<li>add 寄存器,常数<code>add ax,2</code></li>
<li>add 寄存器,变量<code>add ax,ds:[1000h]</code></li>
<li>add 变量,寄存器<code>add ds:[1000h],ax</code></li>
<li>add 变量,常数<code>add word ptr ds:[1000h],2</code></li>
</ul>
<p><strong><em>word ptr</em></strong><br>由于源操作数的长度要和目标操作数一样长，但是常数的长度是不确定的，可以是8，16，32字节等等，所以要在变量前面做一个限制，其中，word是16位的变量，还有byte ptr 和 dword ptr 分别表示8位和32位的变量。<br>这里的prt其实是pointer的意思。</p>
<h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><p>&amp; | ^ ~ &lt;&lt; &gt;&gt; _rotl() _rotr() 对应着c语言中的逻辑操作，在汇编中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and ax,bx          ;与操作</span><br><span class="line">or ax,bx           ;或操作</span><br><span class="line">xor ax,bx          ;异或操作</span><br><span class="line">not ax             ;非操作，单目运算符</span><br><span class="line">shl ax,1           ;左移位，移动丢失，循环不丢失</span><br><span class="line">shr ax,1           ;右移位</span><br><span class="line">rol ax,1           ;左循环移位rotate left</span><br><span class="line">ror ax,1           ;右循环移位rotate right</span><br><span class="line">sal                ;算术左移shift left</span><br><span class="line">sar                ;算术右移shift right</span><br><span class="line">rcl                ;带位左移</span><br><span class="line">rcr                ;带位右移</span><br></pre></td></tr></table></figure>

<h3 id="变量存储与寻址"><a href="#变量存储与寻址" class="headerlink" title="变量存储与寻址"></a>变量存储与寻址</h3><p>在data段定义的变量会被存储在一个段内<br>物理地址：用一整个数表示的地址叫做物理地址，比如12345h<br>逻辑地址：用段地址加偏移量来表示目标数的位置的方式叫逻辑地址，比如1234:0000h<br>段地址的起始地址的二进制后四位必须是0，然后从0000～FFFF，是一个段。<br>段的最大长度是10000h字节，也就是64k<br>比如1234:0000h一直到1234:FFFFh是一个段</p>
<p><strong><em>怎么引用12345h</em></strong><br>在8086系统中，可用的内存地址是5位十六进制，因为地址线只有20条，最多可以寻址1M的内存空间，如果想直接引用12345h中的数例如<code>mov al,[12345h]</code>将会报错，因为不可接受超过16位二进制的值，所以要用段地址加偏移地址来完成这个位置数字的调用，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dx 1000h</span><br><span class="line">mov ds dx           ;ds不可以用常数来赋值，一定要用别的寄存器赋值</span><br><span class="line">mov al ds:[2398h]   ;这样就不会报错了</span><br><span class="line"></span><br><span class="line">mov al 1000h:[2398h];依旧报错，因为引用时段地址不可以用常数</span><br></pre></td></tr></table></figure>

<p>而对于32位的80386系统，偏移地址有8位，可以引用4G的内存地址，引用内存地址会更加的简单方便。<br>但是16位的cpu工作模式是在实模式下，而32位工作在保护模式下。在实模式下，用户程序具有和操作系统一样的权限，可以执行任何指令，保护模式下，用户程序权限低于操作系统，有些特权指令无法执行。</p>
<p>同时，在16位的5位十六进制范围的内存中，并不是所有都是用户可用的内存，其中A000～F000段的内容分别被别的应用占用，留给用户的只有0000:0000～9000:FFFF这块640k的地址。<br>被别的应用用掉的地址是被别的内存映射(mapping)使用，比如，A000映射的显卡的内存，如果在A000段写入一个数据，会在屏幕上直接显示，B000段也是与显示相关，而F000段则映射来POST(power on self test)的ROM中的代码，这也导致F000段内是只读的不可写入。</p>
<p><strong><em>都有哪些寄存器</em></strong><br>在8086CPU中，寄存器为16位寄存器，包括有：</p>
<ul>
<li>ax,bx,cx,dx</li>
<li>sp,bp,si,di</li>
<li>FL,IP</li>
<li>cs,ds,es,ss</li>
</ul>
<p>其中bx,bp,si,di可以用来表示地址。<br>而cs,ds,es,ss常用于赋值段地址。</p>
<p><strong><em>怎么把128k的内存设为0</em></strong><br>假如要把1000h：0000起长度为128K的内存填成0：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,1000h</span><br><span class="line">next_block</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,0</span><br><span class="line">next:</span><br><span class="line">mov byte ptr ds:[bx],0</span><br><span class="line">add bx,1</span><br><span class="line">sub cx,1;cx&#x3D;FFFF</span><br><span class="line">jnz next_byte</span><br><span class="line">mov ax,ds</span><br><span class="line">add ax,1000h</span><br><span class="line">sub dx,1</span><br><span class="line">jnz next_block</span><br></pre></td></tr></table></figure>
<p><strong><em>寻址</em></strong><br>直接寻址 <code>ds:[常数]</code><br>间接寻址 <code>ds:[寄存器]</code></p>
<ul>
<li>bx,bp,si,di,这些可以用作间接寻址的寄存器</li>
<li>寄存器可以是<code>bx</code>，<code>bx+2</code>，<code>bx+si</code>，<code>bx+si+2</code>，常数还可以是负数,两个寄存器只能相加，寄存器只能够b开头选一个i结尾选一个</li>
</ul>
<h3 id="ptr修饰"><a href="#ptr修饰" class="headerlink" title="ptr修饰"></a>ptr修饰</h3><p>源操作数为常数的时候一定要加ptr修饰变量：</p>
<ul>
<li><code>byte ptr</code> 相当于<code>char*</code></li>
<li><code>word ptr</code> 相当于<code>short int *</code></li>
<li><code>dword ptr</code> 相当于<code>long int *</code></li>
</ul>
<p>除了以上三个之外还有用来修饰标号的另外两种ptr：</p>
<ul>
<li><code>near ptr</code> 近 当前指令与目标地址在同一个段内</li>
<li><code>far ptr</code> 远 不在同一个段内</li>
</ul>
<p>使用时前面通常是jmp或call<br>例如：<br><code>jmp near ptr next</code><br><code>jmp far ptr away</code></p>
<h3 id="文本编辑模式"><a href="#文本编辑模式" class="headerlink" title="文本编辑模式"></a>文本编辑模式</h3><h3 id="图形模式编程"><a href="#图形模式编程" class="headerlink" title="图形模式编程"></a>图形模式编程</h3><p><strong><em>颜色对应</em></strong></p>
<table>
<thead>
<tr>
<th>0黑</th>
<th>1蓝</th>
<th>2绿</th>
<th>3青</th>
<th>4红</th>
<th>5粉</th>
<th>6棕</th>
<th>7白</th>
</tr>
</thead>
<tbody><tr>
<td>8灰</td>
<td>9亮蓝</td>
<td>A亮绿</td>
<td>B</td>
<td>C亮红</td>
<td>D亮粉</td>
<td>E黄</td>
<td>F很亮很亮白</td>
</tr>
</tbody></table>
<p>高四位表示颜色背景，低四位表示前景颜色</p>
<h2 id="函数集"><a href="#函数集" class="headerlink" title="函数集"></a>函数集</h2><h3 id="int-21h-函数集"><a href="#int-21h-函数集" class="headerlink" title="int 21h 函数集"></a>int 21h 函数集</h3><p>int 21h是dos系统的内核函数集，代码是由微软编写的。<br>调用方法 mov ah num_of_faction<br>用ah的值表示要调用的函数<br>int 21h 9   ;输出一个以$结尾的字符串<br>int 21h 2   ;输出一个字符，每输出一个要调用一次<br>int 21h 4Ch ;释放内存，等于程序结束</p>
<h3 id="int-10h"><a href="#int-10h" class="headerlink" title="int 10h"></a>int 10h</h3><p>int 10h是与显示相关的BIOS中断，是BIOS(basic input output system)的一部分，其代码是由主板的生产厂家写的，代码保存在ROM中。</p>
<h3 id="int-13h"><a href="#int-13h" class="headerlink" title="int 13h"></a>int 13h</h3><p>int 13h是BIOS中的一部分，与磁盘的输入输出有关。</p>
<h3 id="int-16h"><a href="#int-16h" class="headerlink" title="int 16h"></a>int 16h</h3><p>int 16h是BIOS中的一部分，与键盘的输入有关。</p>
<h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><p><a href="http://bbs.pediy.com" target="_blank" rel="noopener">http://bbs.pediy.com</a><br><a href="http://www.52pojie.cn" target="_blank" rel="noopener">http://www.52pojie.cn</a><br><a href="http://forum.exetools.tom" target="_blank" rel="noopener">http://forum.exetools.tom</a><br><a href="http://www.tuts4you.com" target="_blank" rel="noopener">http://www.tuts4you.com</a><br><a href="http://www.woodmann.com/crackz" target="_blank" rel="noopener">http://www.woodmann.com/crackz</a><br><a href="http://www.masm32.com" target="_blank" rel="noopener">http://www.masm32.com</a></p>
<h2 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h2><h3 id="把输入存入数组，转大写并去掉空格后输出"><a href="#把输入存入数组，转大写并去掉空格后输出" class="headerlink" title="把输入存入数组，转大写并去掉空格后输出"></a>把输入存入数组，转大写并去掉空格后输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">s db 100 dup(0)</span><br><span class="line">t db 100 dup(0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">    mov ax,data         </span><br><span class="line">    mov ds,ax           ;赋值段地址给ds</span><br><span class="line">    mov si,0            ;si初始设为0</span><br><span class="line">getchar:</span><br><span class="line">    mov ah,1            ;调用int21-01h指令读入一个字符到al中</span><br><span class="line">    int 21h</span><br><span class="line">    cmp al,0Dh          ;判断是不是回车</span><br><span class="line">    je getchar_done     ;是回车，跳转到getchar_done</span><br><span class="line">    mov s[si],al        ;不是回车，把al放入s数组</span><br><span class="line">    add si,1            ;si指向数组下一个</span><br><span class="line">    jmp getchar         ;循环</span><br><span class="line">getchar_done:      </span><br><span class="line">    mov al,0            ;把当前的回车改成00h</span><br><span class="line">    mov s[si],al</span><br><span class="line">outputa:                ;再完成存入s后立刻输出一个回车换行</span><br><span class="line">    mov ah,2</span><br><span class="line">    mov dl,0Dh</span><br><span class="line">    int 21h             ;输出换行</span><br><span class="line">    mov si,0            ;重新赋值si，di</span><br><span class="line">    mov di,0</span><br><span class="line">put_s_to_t:            </span><br><span class="line">    mov al,s[si]        ;将s数组中的数依次取出</span><br><span class="line">    add si,1        </span><br><span class="line">    cmp al,20h          </span><br><span class="line">    je put_s_to_t       ;若元素为空格则丢弃该元素</span><br><span class="line">    cmp al,&#39;a&#39;          ;如果ascii小于‘a&#39;，跳转al_other</span><br><span class="line">    jb al_other         ;al&lt;a</span><br><span class="line">    cmp al,&#39;z&#39;          ;如果ascii大于&#39;z&#39;，跳转al_other</span><br><span class="line">    ja al_other         ;al&gt;z</span><br><span class="line">    sub al,32           ;否则，是小写字母，ascii减32变大写保存到数组t中</span><br><span class="line">al_other:               ;元素为其它字符则原样保存到t中</span><br><span class="line">    mov t[di],al        </span><br><span class="line">    add di,1</span><br><span class="line">    cmp al,00h          ;判断是否到s的结束位置</span><br><span class="line">    jne put_s_to_t      </span><br><span class="line">    mov di,0            </span><br><span class="line">output:                 ;将t数组输出</span><br><span class="line">    mov ah,2</span><br><span class="line">    mov dl,t[di]</span><br><span class="line">    int 21h</span><br><span class="line">    add di,1</span><br><span class="line">    cmp dl,00h          </span><br><span class="line">    jne output                </span><br><span class="line">    mov ah,2            ;再次输出一个换行</span><br><span class="line">    mov dl,0Dh</span><br><span class="line">    int 21h             </span><br><span class="line">exit:</span><br><span class="line">    mov ah,4Ch</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>

<h3 id="在文本模式下打印ascii码表"><a href="#在文本模式下打印ascii码表" class="headerlink" title="在文本模式下打印ascii码表"></a>在文本模式下打印ascii码表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code segment </span><br><span class="line">assume cs:code</span><br><span class="line">main:</span><br><span class="line">    mov ax,0B800h</span><br><span class="line">    mov es,ax                   ;赋值段地址为映射的显卡地址B800</span><br><span class="line">    mov al,00h                  ;当前ascii码</span><br><span class="line">    mov di,00h                  ;地址</span><br><span class="line">    mov cl,00h                  ;统计256位ascii码是否用尽</span><br><span class="line">    mov si,00h                  ;记录行开头</span><br><span class="line">    mov ch,11                   ;最多11列</span><br><span class="line">next_column:</span><br><span class="line">    mov dl,25                   ;每列25个元素，每次循环开始时赋值25</span><br><span class="line">    mov si,di                   ;把开头的di值保护在si中</span><br><span class="line">row:</span><br><span class="line">    mov byte ptr es:[di],al     ;写入ascii码</span><br><span class="line">    mov byte ptr es:[di+1],0Ch  ;写入ascii码的颜色信息</span><br><span class="line">    mov bl,al                   ;</span><br><span class="line">    mov bh,al</span><br><span class="line">    and bl,0Fh                  ;取al低4位</span><br><span class="line">    and bh,0F0h                 ;取al高4位</span><br><span class="line">    ror bh,1                    ;bh连续右移4位</span><br><span class="line">    ror bh,1</span><br><span class="line">    ror bh,1</span><br><span class="line">    ror bh,1</span><br><span class="line">highcmp:                        ;高位大于9比较</span><br><span class="line">    cmp bh,9</span><br><span class="line">    ja buchanghigh              ;大于时跳转到补偿函数</span><br><span class="line">lowcmp:</span><br><span class="line">    cmp bl,9                    ;同上，大于9时跳转到补偿函数</span><br><span class="line">    ja buchanglow</span><br><span class="line">    jmp bubuchang</span><br><span class="line">buchanghigh:                    ;补偿加7</span><br><span class="line">    add bh,7</span><br><span class="line">    jmp lowcmp</span><br><span class="line">buchanglow:                     ;补偿加7</span><br><span class="line">    add bl,7</span><br><span class="line">bubuchang:                      ;不补偿下，直接加30h变成对应数字的ascii码</span><br><span class="line">    add bl,30h</span><br><span class="line">    add bh,30h</span><br><span class="line">    mov byte ptr es:[di+2],bh   ;写入第一位</span><br><span class="line">    mov byte ptr es:[di+3],0Ah  ;写入颜色</span><br><span class="line">    mov byte ptr es:[di+4],bl   ;写入第二位</span><br><span class="line">    mov byte ptr es:[di+5],0Ah  ;写入颜色</span><br><span class="line">    add di,160                  ;开始下一行  </span><br><span class="line">    sub cl,1                    ;ascii码数减1</span><br><span class="line">    jz done                     ;如果ascii码用完，跳转到done</span><br><span class="line">    add al,1                    ;下一个ascii码</span><br><span class="line">    sub dl,1                    ;行数减1</span><br><span class="line">    jnz row                     ;循环到25行全部打印完</span><br><span class="line">    add si,14                   ;下一列开头的地址</span><br><span class="line">    mov di,si</span><br><span class="line">    sub ch,1                    ;列数减1</span><br><span class="line">    jnz next_column             ;循环，直到列数为0</span><br><span class="line">done:</span><br><span class="line">    mov ah,00h                  ;键入任意键中断</span><br><span class="line">    int 16h</span><br><span class="line">    mov ah,4Ch                  ;结束</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>

<p>持续更新中～</p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论（一）</title>
    <url>/2020/04/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法导论"><a href="#算法导论" class="headerlink" title="算法导论"></a>算法导论</h1><p>参考书《算法导论》</p>
<h2 id="1-算法的意义"><a href="#1-算法的意义" class="headerlink" title="1.算法的意义"></a>1.算法的意义</h2><p>计算机资源是廉价的，但不是免费的，优秀的算法可以节省资源，强化功能。</p>
<a id="more"></a>
<h2 id="2-算法基础"><a href="#2-算法基础" class="headerlink" title="2.算法基础"></a>2.算法基础</h2><p>从排序问题开始<br>输入：n个数的一个序列（a1，a2…an）<br>输出：升序</p>
<h3 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h3><p>每次拿一个元素，插入集合的正确位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insertion-sort:</span><br><span class="line">for j&#x3D;2 to A.length         ;</span><br><span class="line">    key&#x3D;A[j]                ;</span><br><span class="line">    i&#x3D;j-1                   ;把A插入</span><br><span class="line">    while i&gt;0 and A[i]&gt;key</span><br><span class="line">        A[i+1]&#x3D;A[i]         ;腾位子</span><br><span class="line">        i&#x3D;i-1               ;1～j是已经排好的序列</span><br><span class="line">    A[i+1]&#x3D;key</span><br></pre></td></tr></table></figure>
<p><strong><em>循环不变式</em></strong><br>主要用于帮助理解算法的正确性，必须有三条性质</p>
<ol>
<li>初始化：循环的第一次迭代之前，它为真</li>
<li>保持：如果循环的某次迭代之前是真，那么下次迭代之前它还是真</li>
<li>终止：在循环终止时，不变式为我们提供一个有用的性质，有助于证明算法正确性</li>
</ol>
<h3 id="2-2-分析算法"><a href="#2-2-分析算法" class="headerlink" title="2.2 分析算法"></a>2.2 分析算法</h3><p>使用的是RAM模型，指令是一条条的执行的，不考虑数据读取的影响<br>输入规模：量度是输入中的相数<br>运行时间：量度是执行的基本操作数或步数</p>
<p>讨论时一般讨论最坏情况的计算</p>
<p><strong><em>增长量级</em></strong><br>只考虑运行时间中最重要的项，同时也忽略常系数。如果一个算法的最坏情况运行时间具有比另一个算法更低的增长量级，一般认为前者更有效</p>
<p>选择排序：找到最小值，然后把它和a1交换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for j&#x3D;1 to A.length-1          ;n-1</span><br><span class="line">    i&#x3D;j                        ;n-1</span><br><span class="line">    min&#x3D;A[i]                   ;n-1</span><br><span class="line">    for i to A.length          ;(n-1)*n&#x2F;2</span><br><span class="line">        if min&gt;A[i]            ;(n-1)*n&#x2F;2</span><br><span class="line">            temp&#x3D;min</span><br><span class="line">            min&#x3D;A[i]</span><br><span class="line">            A[i]&#x3D;temp</span><br><span class="line">    A[j]&#x3D;min</span><br></pre></td></tr></table></figure>
<p>所以选择排序也是$n^2$级别的算法</p>
<h3 id="2-3-设计算法"><a href="#2-3-设计算法" class="headerlink" title="2.3 设计算法"></a>2.3 设计算法</h3><h4 id="2-3-1-分治法"><a href="#2-3-1-分治法" class="headerlink" title="2.3.1 分治法"></a>2.3.1 分治法</h4><p>思路：把原问题分解为几个规模比较小但类似的问题，递归求解这些子问题，然后再合并这些子问题的解来建立原问题的解<br>分治模式在每一层都有三个步骤：</p>
<ol>
<li>分解</li>
<li>解决</li>
<li>合并</li>
</ol>
<p><strong><em>归并排序</em></strong><br>思路：</p>
<ol>
<li>分解：分解为n/2个元素的两个子序列</li>
<li>解决：使用归并排序递归解决两个子序列的排序</li>
<li>合并：合并两个排好的子序列<br>合并的过程是关键，所做的事情就是，每次比较两个的最上面的牌，取较小的那个，当有一个被取完的时候，剩下的一个数组就全部放入框。<br>这个步骤用一个n级的merge函数完成</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">merge(A,p,q,r)</span><br><span class="line">    n1&#x3D;q-p+1</span><br><span class="line">    n2&#x3D;r-q</span><br><span class="line">    let L[1...n1+1] and R[1,n2+1] be new arrays</span><br><span class="line">    for i&#x3D;1 to n1</span><br><span class="line">        L[i]&#x3D;A[p+i-1]</span><br><span class="line">    for j&#x3D;1 to n2</span><br><span class="line">        R[j]&#x3D;A[q+j]</span><br><span class="line">    L[n1+1]&#x3D;MAX</span><br><span class="line">    R[n2+1]&#x3D;MAX</span><br><span class="line">    i&#x3D;1</span><br><span class="line">    j&#x3D;1</span><br><span class="line">    for k&#x3D;p to r</span><br><span class="line">        if L[i]&lt;&#x3D;R[j]</span><br><span class="line">            A[k]&#x3D;L[i]</span><br><span class="line">            i&#x3D;i+1</span><br><span class="line">        else </span><br><span class="line">            A[k]&#x3D;R[j]</span><br><span class="line">            j&#x3D;j+1</span><br></pre></td></tr></table></figure>

<p>python实现 用python的list的特性可以很方便的实现归并排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    c = []</span><br><span class="line">    h = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; len(a) <span class="keyword">and</span> h &lt; len(b)):</span><br><span class="line">        <span class="keyword">if</span> a[j] &lt; b[h]:</span><br><span class="line">            c.append(a[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c.append(b[h])</span><br><span class="line">            h += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> j == len(a):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> b[h:]:</span><br><span class="line">            c.append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a[j:]:</span><br><span class="line">            c.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(lists)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(lists) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> lists</span><br><span class="line">    middle = int(len(lists)/<span class="number">2</span>)</span><br><span class="line">    left = merge_sort(lists[:middle])</span><br><span class="line">    right = merge_sort(lists[middle:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-分析分治算法"><a href="#2-3-2-分析分治算法" class="headerlink" title="2.3.2 分析分治算法"></a>2.3.2 分析分治算法</h3><p>分治算法的时间一般来自三个部分，假设T(n)是规模为n的一个问题，设D(n)是分解子问题需要的时间，C(n)是合并子问题需要的时间，a是一个子问题需要的时间，分解成b个问题，则<br>$$T(n)=\Xi (1)···········n&lt;=c$$<br>$$T(n)=aT(\frac{n}{b})+D(n)+C(n)$$</p>
<p>通过构建递归树，每一层的代价是n，一共有$n\log n+1$层，所以，递归的代价是$n\log n$</p>
<h2 id="插入排序和选择排序"><a href="#插入排序和选择排序" class="headerlink" title="插入排序和选择排序"></a>插入排序和选择排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">listsorted</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,A)</span>:</span></span><br><span class="line">        self.A=A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchsorted</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,len(self.A)<span class="number">-1</span>):</span><br><span class="line">            i=j</span><br><span class="line">            Min=self.A[i]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(j,len(self.A)):</span><br><span class="line">                <span class="keyword">if</span> Min&gt;self.A[i]:</span><br><span class="line">                    Min,self.A[i]=self.A[i],Min</span><br><span class="line">            A[j]=Min</span><br><span class="line">        <span class="keyword">return</span> self.A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionsorted</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(self.AA)):</span><br><span class="line">            key=self.A[j]</span><br><span class="line">            i=j<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> key&lt;self.A[i]:</span><br><span class="line">                self.A[i+<span class="number">1</span>]=self.A[i]</span><br><span class="line">                i=i<span class="number">-1</span></span><br><span class="line">            self.A[i+<span class="number">1</span>]=key</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——概述</title>
    <url>/2020/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="计算机网络——概述"><a href="#计算机网络——概述" class="headerlink" title="计算机网络——概述"></a>计算机网络——概述</h1><p>参考书：《计算机网络》</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>计算机网络由若干节点和链接这些节点的链路组成。节点可以是计算机，集线器，路由器等等。互连网把许多网络用路由器链接起来。习惯上，与网络相连的计算机称为主机</p>
<a id="more"></a>
<h3 id="互联网基础结构发展"><a href="#互联网基础结构发展" class="headerlink" title="互联网基础结构发展"></a>互联网基础结构发展</h3><p>第一阶段：由ARPANET向互联网发展。（互连网和互联网不同）<br>第二阶段：建成三级结构的互联网<br>第三阶段：逐渐形成多层次ISP（互联网服务提供者（就类似移动，联通））结构的互联网，逐渐出现IXP（互联网交换点），用于快速的交换不同分组。</p>
<h4 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h4><p>互联网拓扑结构复杂，地理上覆盖全球，工作方式上分为两块：</p>
<ol>
<li>边缘部分：由所有在互联网上的主机组成</li>
<li>核心部分：由大量网络和链接网络的路由器组成，为边缘部分提供服务</li>
</ol>
<h5 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h5><p>这些边缘部分的主机又称为端系统。边缘部分利用核心部分提供的服务使得众多主机之间能够相互通信并交换或共享信息。计算机通信是指主机A的某个进程和主机B的另一个进程进行通信。在网络边缘的端系统之间的通信方式可以分为两大类：客户-服务器（C/S方式）和对等方式（P2P)</p>
<h5 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h5><p>网络核心部分起特殊作用的是路由器，是一种专用计算机，是实现分组交换的关键构件，任务是转发收到的分组。</p>
<p>1.电路交换：特点，端到端资源全部占用<br>2.分组交换：采用存储转发技术，把报文划分成多个等长的数据段，每个小段前面加上必要的控制信息组成的首部，构成一个分组，分组也叫包，首部叫包头</p>
<p>报文：要发送的整块数据称为一个报文</p>
<h4 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h4><p>按照网络的作用范围来分：</p>
<ol>
<li>WAN 广域网</li>
<li>MAN 城域网</li>
<li>LAN 局域网</li>
<li>PAN 个人区域网</li>
</ol>
<p>按照使用者：</p>
<ol>
<li>公用网</li>
<li>专用网</li>
</ol>
<h4 id="计算机网络性能"><a href="#计算机网络性能" class="headerlink" title="计算机网络性能"></a>计算机网络性能</h4><p>性能指标有以下7个：</p>
<ul>
<li>速率：bit是一个二进制数字（0，1），速率指比特率，单位bit/s，或bps，一般提到网络速率时是指额定数率或标称速率。</li>
<li>带宽：单位时间可以通过的最高数据率，单位bit/s</li>
<li>吞吐量：实际单位时间通过的数据量</li>
<li>时延：从一段到另一端需要的时间，它由发送时延，传播时延，处理时延，排队时延</li>
<li>时延带宽积</li>
<li>往返时间RTT</li>
<li>利用率</li>
</ul>
<p>网络的非性能指标：</p>
<ul>
<li>费用</li>
<li>质量</li>
<li>标准化</li>
<li>可靠性</li>
<li>可扩展性和可升级性</li>
<li>易于管理和维护</li>
</ul>
<h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p>网络数据交换需要建立规则，也就是网络协议。网络协议主要由以下三个要素组成：</p>
<ul>
<li>语法：数据与控制信息的结构或格式</li>
<li>语义：发出何种控制信息，完成何种动作以及何种响应</li>
<li>同步：事件实现顺序的详细说明</li>
</ul>
<p>五层网络结构：</p>
<ul>
<li>应用层</li>
<li>运输层：任务是负责向两台主机进程之间的通信提供数据传输服务</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
